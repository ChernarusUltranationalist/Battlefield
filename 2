import host
import sys

from bf2.Timer import Timer

class GameStatus:
	Playing = 1
	EndGame = 2
	PreGame = 3
	Paused = 4
	RestartServer = 5
	NotConnected = 6

playerManager = None
objectManager = None
triggerManager = None
gameLogic = None
serverSettings = None

g_debug = 0


# set up singletons
import bf2.PlayerManager
import bf2.ObjectManager
import bf2.TriggerManager
import bf2.GameLogic
playerManager = bf2.PlayerManager.PlayerManager()
objectManager = bf2.ObjectManager.ObjectManager()
triggerManager = bf2.TriggerManager.TriggerManager()
gameLogic = bf2.GameLogic.GameLogic()
serverSettings = bf2.GameLogic.ServerSettings()

# these are for wrapping purposes when converting c++ pointers into python objects
playerConvFunc = playerManager.getPlayerByIndex

class fake_stream:
	"""Implements stdout and stderr on top of BF2's log"""
	def __init__(self, name):
		self.name = name
		self.buf = ''

	def write(self, str):
		if len(str) == 0: return
		self.buf += str
		if str[-1] == '\n':
			host.log(self.name + ': ' + self.buf[0:-1])
			self.buf = ''

	def flush(self): pass
	def close(self): pass

class fake_stream2:
	"""Implements stdout and stderr on top of BF2's log"""
	def __init__(self, name):
		self.buf = [str(name), ': '] 

	def write(self, str):
		if len(str) == 0: return
		if str[-1] != '\n':
			self.buf.append (str)
		else:
			self.buf.append (str[0:-1])
			host.log("".join (self.buf))
			self.buf = [] 

	def flush(self): pass
	def close(self): pass

def init_module():
	# set up stdout and stderr to map to the host's logging function
	sys.stdout = fake_stream('stdout')
	sys.stderr = fake_stream('stderr')

	import game.scoringCommon
	game.scoringCommon.init()
	
	try:
		import bf2.stats.stats
	except ImportError:
		print "Official stats module not found."
	else:
		bf2.stats.stats.init()

	try:
		import bf2.stats.endofround
	except ImportError:
		print "Endofround module not found."
	else:
		bf2.stats.endofround.init()


	if not gameLogic.isAIGame():
	
		try:
			import bf2.stats.snapshot
		except ImportError:
			print "Snapshot module not found."
		else:
			bf2.stats.snapshot.init()
		
		try:
			import bf2.stats.medals
		except ImportError:
			print "Medal awarding module not found."
		else:
			bf2.stats.medals.init()
	
		try:
			import bf2.stats.rank
		except ImportError:
			print "Rank awarding module not found."
		else:
			bf2.stats.rank.init()
		
	try:
		import bf2.stats.unlocks
	except ImportError:
		print "Unlock awarding module not found."
	else:
		bf2.stats.unlocks.init()
		
	try:
		import bf2.stats.fragalyzer_log
	except ImportError:
		print "Fragalyzer log module not found."
	else:
		bf2.stats.fragalyzer_log.init()










# game logic


import host

class GameLogic:
	def __init__(self):
		print "GameLogic created"

	def getModDir(self): return host.sgl_getModDirectory()
	def getMapName(self): return host.sgl_getMapName()
	def getWorldSize(self): return host.sgl_getWorldSize()
	def getTeamName(self, team): return host.sgl_getParam('teamName', team, 0)
	def isAIGame(self): return host.sgl_getIsAIGame()

	def sendClientCommand(self, playerId, command, args): return host.sgl_sendPythonEvent(playerId, command, args)
	def sendGameEvent(self, player, event, data): return host.sgl_sendGameLogicEvent(player.index, event, data)
	def sendMedalEvent(self, player, type, value): return host.sgl_sendMedalEvent(player.index, type, value)
	def sendRankEvent(self, player, rank, score): return host.sgl_sendRankEvent(player.index, rank, score)
	
	def sendServerMessage(self, playerId, message): return host.sgl_sendTextMessage(playerId, 10, 1, message)
	
	def getTicketState(self, team): return host.sgl_getParam('ticketState', team, 0)
	def setTicketState(self, team, value): return host.sgl_setParam('ticketState', team, value, 0)
	
	def getTickets(self, team): return host.sgl_getParam('tickets', team, 0)
	def setTickets(self, team, value): return host.sgl_setParam('tickets', team, value, 0)
	
	def getDefaultTickets(self, team): return host.sgl_getParam('startTickets', team, 0)
	
	def getTicketChangePerSecond(self, team): return host.sgl_getParam('ticketChangePerSecond', team, 0, 0)
	def setTicketChangePerSecond(self, team, value): return host.sgl_setParam('ticketChangePerSecond', team, value, 0)
	
	def getTicketLimit(self, team, id): return host.sgl_getParam('ticketLimit', team, id)
	def setTicketLimit(self, team, id, value): return host.sgl_setParam('ticketLimit', team, id, value)
	
	def getDefaultTicketLossPerMin(self, team): return host.sgl_getParam('defaultTicketLossPerMin', team, 0)
	def getDefaultTicketLossAtEndPerMin(self): return host.sgl_getParam('defaultTicketLossAtEndPerMin', 0, 0)
	
	def getWinner(self): return host.sgl_getParam('winner', 0, 0)
	def getVictoryType(self): return host.sgl_getParam('victoryType', 0, 0)
	
	def setHealPointLimit(self, value): return host.sgl_setParam('healScoreLimit', 0, value, 0)
	def setRepairPointLimit(self, value): return host.sgl_setParam('repairScoreLimit', 0, value, 0)
	def setGiveAmmoPointLimit(self, value): return host.sgl_setParam('giveAmmoScoreLimit', 0, value, 0)
	def setTeamDamagePointLimit(self, value): return host.sgl_setParam('teamDamageScoreLimit', 0, value, 0)
	def setTeamVehicleDamagePointLimit(self, value): return host.sgl_setParam('teamVehicleDamageScoreLimit', 0, value, 0)
	
	
class ServerSettings:
	def __init__(self):
		print "Serversettings created"
	
	def getTicketRatio(self): return host.ss_getParam('ticketRatio')
	def getTeamRatioPercent(self): return host.ss_getParam('teamRatioPct')
	def getMaxPlayers(self): return host.ss_getParam('maxPlayers')
	def getGameMode(self): return host.ss_getParam('gameMode')
	def getMapName(self): return host.ss_getParam('mapName')
	def getTimeLimit(self): return host.ss_getParam('timeLimit')
	def getScoreLimit(self): return host.ss_getParam('scoreLimit')
	def getAutoBalanceTeam(self): return host.ss_getParam('autoBalance')
	def getTKPunishEnabled(self): return host.ss_getParam('tkpEnabled')
	def getTKNumPunishToKick(self): return host.ss_getParam('tkpNeeded')
	def getTKPunishByDefault(self): return host.ss_getParam('tkpDefault')
	
	def getUseGlobalRank(self): return host.ss_getParam('globRank')
	def getUseGlobalUnlocks(self): return host.ss_getParam('globUnlocks')






import host


class ObjectManager:
	def __init__(self):
		print "ObjectManager created"

	def getObjectsOfType(self, type):
		return host.omgr_getObjectsOfType(type)

	def getObjectsOfTemplate(self, templ):
		return host.omgr_getObjectsOfTemplate(templ)






import host

# ingame scoremanager link
ingameScores = ('deaths','kills','TKs','score','skillScore','rplScore','cmdScore','fracScore','rank','firstPlace','secondPlace','thirdPlace',
		'bulletsFired','bulletsGivingDamage','bulletsFiredAndClear','bulletsGivingDamageAndClear')

class PlayerScore:
	def __init__(self, index):
		self.__dict__['index'] = index
		self.reset()

	def reset(self):
		# these scores are only tracked in script
		self.__dict__['heals'] = 0
		self.__dict__['ammos'] = 0
		self.__dict__['repairs'] = 0
		self.__dict__['damageAssists'] = 0
		self.__dict__['passengerAssists'] = 0
		self.__dict__['driverAssists'] = 0
		self.__dict__['targetAssists'] = 0
		self.__dict__['driverSpecials'] = 0
		self.__dict__['revives'] = 0
		self.__dict__['teamDamages'] = 0
		self.__dict__['teamVehicleDamages'] = 0
		self.__dict__['cpCaptures'] = 0
		self.__dict__['cpDefends'] = 0
		self.__dict__['cpAssists'] = 0
		self.__dict__['suicides'] = 0
		self.__dict__['cpNeutralizes'] = 0
		self.__dict__['cpNeutralizeAssists'] = 0

	def __getattr__(self, name):
		if name in self.__dict__: return self.__dict__[name]
		elif name == 'dkRatio':
			kills = host.pmgr_getScore(self.index, 'kills')
			if kills == 0:
				# div by zero is undefined -> 0:0 = 1 1:0 = 2 1:1 = 1
				return 1.0 * host.pmgr_getScore(self.index, 'deaths') + 1 
			else:
				return 1.0 * host.pmgr_getScore(self.index, 'deaths') / kills
		elif name in ingameScores: 
			return host.pmgr_getScore(self.index, name)
		else:
			raise AttributeError, name

	def __setattr__(self, name, value):
		if name in self.__dict__: 
			self.__dict__[name] = value 
			return None
		elif name in ingameScores: 
			return host.pmgr_setScore(self.index, name, value)
		else:
			raise AttributeError, name

		

class Player:
	def __init__(self, index):
		self.index = index
		self.score = PlayerScore(index)

	def isValid(self): return host.pmgr_isIndexValid(self.index)
	def isRemote(self): return host.pmgr_p_get("remote", self.index)
	def isAIPlayer(self): return host.pmgr_p_get("ai", self.index)
	def isAlive(self): return host.pmgr_p_get("alive", self.index)
	def isManDown(self): return host.pmgr_p_get("mandown", self.index)
	def isConnected(self): return host.pmgr_p_get("connected", self.index)
	def getProfileId(self): return host.pmgr_p_get("profileid", self.index)

	def isFlagHolder(self): return host.pmgr_p_get("fholder", self.index)

	def getTeam(self): return host.pmgr_p_get("team", self.index)
	def setTeam(self, t): return host.pmgr_p_set("team", self.index, t)
	def getPing(self): return host.pmgr_p_get("ping", self.index)

	def getSuicide(self): return host.pmgr_p_get("suicide", self.index)
	def setSuicide(self, t): return host.pmgr_p_set("suicide", self.index, t)
	
	def getTimeToSpawn(self): return host.pmgr_p_get("tts", self.index)
	def setTimeToSpawn(self, t): return host.pmgr_p_set("tts", self.index, t)

	def getSquadId(self): return host.pmgr_p_get("sqid", self.index)
	def isSquadLeader(self): return host.pmgr_p_get("isql", self.index)
	def isCommander(self): return host.pmgr_p_get("commander", self.index)

	def getName(self): return host.pmgr_p_get("name", self.index)
	def setName(self, name): return host.pmgr_p_set("name", self.index, name)

	def getSpawnGroup(self): return host.pmgr_p_get("sgr", self.index)
	def setSpawnGroup(self, t): return host.pmgr_p_set("sgr", self.index, t)
	
	def getKit(self): return host.pmgr_p_get("kit", self.index)
	def getVehicle(self): return host.pmgr_p_get("vehicle", self.index)
	def getDefaultVehicle(self): return host.pmgr_p_get("defaultvehicle", self.index)
	def getPrimaryWeapon(self): return host.pmgr_p_get("weapon", self.index, 0)

	def getAddress(self): return host.pmgr_p_get("addr", self.index)
	
	def setIsInsideCP(self, val): return host.pmgr_p_set("isInsideCP", self.index, val)
	def getIsInsideCP(self): return host.pmgr_p_get("isInsideCP", self.index)
	
class PlayerManager:
	def __init__(self):
		print "PlayerManager created"
		self._pcache = {}
		
	def getNumberOfPlayers(self):
		return host.pmgr_getNumberOfPlayers()
	
	def getCommander(self, team):
		return self.getPlayerByIndex(host.pmgr_getCommander(team))

	def getPlayers(self):
		indices = host.pmgr_getPlayers()
		players = []
		# NOTE: this uses getPlayerByIndex so we return cached player objects
		# whenever we can
		for i in indices: players.append(self.getPlayerByIndex(i))
		return players

	def getPlayerByIndex(self, index):
		# dep: this uses a cache so that all references to a certain player
		# index will always yield the same object, which is useful because you
		# can then test them for object equality
		valid = host.pmgr_isIndexValid(index)
		if not valid: 
			if self._pcache.has_key(index):
				print "Removed player index %d from player cache" % index
				del self._pcache[index]
			return None
		if not self._pcache.has_key(index):
			self._pcache[index] = Player(index)
		return self._pcache[index]
		
	def getNextPlayer(self, index):
		startIndex = index
		p = None
		index = index + 1
		while p == None and index != startIndex:
			p = self.getPlayerByIndex(index)
			index = index + 1
			if index > 255: index = 0
			if index > 63: index = 255
		
		if not p:
			return self.getPlayerByIndex(startIndex)
		else:
			return p

	def getNumberOfPlayersInTeam(self, team):
		players = self.getPlayers()
		inTeam = 0
		for p in players:
			if p.getTeam() == team:
				inTeam += 1
		
		return inTeam
		
	def getNumberOfAlivePlayersInTeam(self, team):
		players = self.getPlayers()
		inTeam = 0
		for p in players:
			if p.getTeam() == team and p.isAlive():
				inTeam += 1
		
		return inTeam
		
	# allows temporary disabling of the onPlayerScore event.
	def enableScoreEvents(self):
		return host.pmgr_enableScoreEvents(1)
	def disableScoreEvents(self):
		return host.pmgr_enableScoreEvents(0)




import host

class Timer:

	def __init__(self, targetFunc, delta, alwaysTrigger, data=None):
		self.targetFunc = targetFunc
		self.data = data
		self.time = host.timer_getWallTime() + delta
		self.interval = 0.0
		self.alwaysTrigger = alwaysTrigger
		host.timer_created(self)

	def __del__(self):
		print "timer object destroyed (rc 0)"

	def destroy(self):
		host.timer_destroy(self)

	def getTime(self):
		return self.time

	def setTime(self, time):
		self.time = time

	def setRecurring(self, interval):
		self.interval = interval

	def onTrigger(self):
		self.targetFunc(self.data)
		


import host

class TriggerManager:

	def createRadiusTrigger(self, object, callback, objName, radius, data=None):
		return host.trig_create(object, callback, objName, radius, 0, data)

	def createHemiSphericalTrigger(self, object, callback, objName, radius, data=None):
		return host.trig_create(object, callback, objName, radius, 1, data)

	def destroyAllTriggers(self):
		host.trig_destroyAll()

	def destroy(self, trig_id):
		host.trig_destroy(trig_id)

	def getObjects(self, trig_id):
		return host.trig_getObjects(trig_id)











import host
import string
from bf2 import g_debug

### Stats

VEHICLE_TYPE_ARMOR 	= 0
VEHICLE_TYPE_AVIATOR	= 1
VEHICLE_TYPE_AIRDEFENSE	= 2
VEHICLE_TYPE_HELICOPTER	= 3
VEHICLE_TYPE_TRANSPORT	= 4
VEHICLE_TYPE_ARTILLERY	= 5
VEHICLE_TYPE_GRNDDEFENSE= 6

VEHICLE_TYPE_PARACHUTE	= 9
VEHICLE_TYPE_SOLDIER	= 10

NUM_VEHICLE_TYPES 	= 11
VEHICLE_TYPE_UNKNOWN 	= NUM_VEHICLE_TYPES


WEAPON_TYPE_ASSAULT 	= 0
WEAPON_TYPE_ASSAULTGRN	= 1
WEAPON_TYPE_CARBINE	= 2
WEAPON_TYPE_LMG		= 3
WEAPON_TYPE_SNIPER	= 4
WEAPON_TYPE_PISTOL	= 5
WEAPON_TYPE_ATAA	= 6
WEAPON_TYPE_SMG		= 7
WEAPON_TYPE_SHOTGUN	= 8

WEAPON_TYPE_KNIFE	= 10
WEAPON_TYPE_C4		= 11
WEAPON_TYPE_CLAYMORE	= 12
WEAPON_TYPE_HANDGRENADE = 13
WEAPON_TYPE_SHOCKPAD	= 14
WEAPON_TYPE_ATMINE	= 15
WEAPON_TYPE_TARGETING	= 16

NUM_WEAPON_TYPES 	= 17
WEAPON_TYPE_UNKNOWN	= NUM_WEAPON_TYPES


KIT_TYPE_AT		= 0
KIT_TYPE_ASSAULT	= 1
KIT_TYPE_ENGINEER	= 2
KIT_TYPE_MEDIC		= 3
KIT_TYPE_SPECOPS	= 4
KIT_TYPE_SUPPORT 	= 5
KIT_TYPE_SNIPER 	= 6

NUM_KIT_TYPES		= 7
KIT_TYPE_UNKNOWN	= NUM_KIT_TYPES


ARMY_USA		= 0
ARMY_MEC		= 1
ARMY_CHINESE		= 2

NUM_ARMIES		= 3
ARMY_UNKNOWN		= NUM_ARMIES


vehicleTypeMap = {
	"usapc_lav25"		: VEHICLE_TYPE_ARMOR,
	"apc_btr90"		: VEHICLE_TYPE_ARMOR,
	"apc_wz551"		: VEHICLE_TYPE_ARMOR,
	"ustnk_m1a2"		: VEHICLE_TYPE_ARMOR,
	"rutnk_t90"		: VEHICLE_TYPE_ARMOR,
	"tnk_type98"		: VEHICLE_TYPE_ARMOR,
	"usair_f18"		: VEHICLE_TYPE_AVIATOR,
	"ruair_mig29"		: VEHICLE_TYPE_AVIATOR,
	"air_j10"		: VEHICLE_TYPE_AVIATOR,
	"usair_f15"		: VEHICLE_TYPE_AVIATOR,
	"ruair_su34"		: VEHICLE_TYPE_AVIATOR,
	"air_su30mkk"		: VEHICLE_TYPE_AVIATOR,
	"air_f35b"		: VEHICLE_TYPE_AVIATOR,
	"usaav_m6"		: VEHICLE_TYPE_AIRDEFENSE,
	"aav_tunguska"		: VEHICLE_TYPE_AIRDEFENSE,
	"aav_type95"		: VEHICLE_TYPE_AIRDEFENSE,
	"usaas_stinger"		: VEHICLE_TYPE_AIRDEFENSE,
	"igla_djigit"		: VEHICLE_TYPE_AIRDEFENSE,
	"wasp_defence_front"	: VEHICLE_TYPE_AIRDEFENSE,
	"wasp_defence_back"	: VEHICLE_TYPE_AIRDEFENSE,
	"usthe_uh60"		: VEHICLE_TYPE_HELICOPTER,
	"the_mi17"		: VEHICLE_TYPE_HELICOPTER,
	"chthe_z8"		: VEHICLE_TYPE_HELICOPTER,
	"ahe_ah1z"		: VEHICLE_TYPE_HELICOPTER,
	"ahe_havoc"		: VEHICLE_TYPE_HELICOPTER,
	"ahe_z10"		: VEHICLE_TYPE_HELICOPTER,
	"jeep_faav"		: VEHICLE_TYPE_TRANSPORT,
	"usjep_hmmwv"		: VEHICLE_TYPE_TRANSPORT,
	"jep_paratrooper"	: VEHICLE_TYPE_TRANSPORT,
	"jep_mec_paratrooper"	: VEHICLE_TYPE_TRANSPORT,
	"jep_vodnik"		: VEHICLE_TYPE_TRANSPORT,
	"jep_nanjing"		: VEHICLE_TYPE_TRANSPORT,
	"uslcr_lcac"		: VEHICLE_TYPE_TRANSPORT,
	"boat_rib"		: VEHICLE_TYPE_TRANSPORT,
	"usart_lw155"		: VEHICLE_TYPE_ARTILLERY,
	"ars_d30"		: VEHICLE_TYPE_ARTILLERY,
	"ats_tow"		: VEHICLE_TYPE_GRNDDEFENSE,
	"ats_hj8"		: VEHICLE_TYPE_GRNDDEFENSE,
	"hmg_m2hb"		: VEHICLE_TYPE_GRNDDEFENSE,
	"chhmg_kord"		: VEHICLE_TYPE_GRNDDEFENSE,
	"mec_bipod"		: VEHICLE_TYPE_GRNDDEFENSE,
	"us_bipod"		: VEHICLE_TYPE_GRNDDEFENSE,
	"ch_bipod"		: VEHICLE_TYPE_GRNDDEFENSE,
#	"TYPE85"		: VEHICLE_TYPE_GRNDDEFENSE,
	"us_soldier"		: VEHICLE_TYPE_SOLDIER,
	"us_heavy_soldier"	: VEHICLE_TYPE_SOLDIER,
	"us_light_soldier"	: VEHICLE_TYPE_SOLDIER,
	"mec_soldier"		: VEHICLE_TYPE_SOLDIER,
	"mec_light_soldier"	: VEHICLE_TYPE_SOLDIER,
	"mec_heavy_soldier"	: VEHICLE_TYPE_SOLDIER,
	"ch_soldier"		: VEHICLE_TYPE_SOLDIER,
	"ch_light_soldier"	: VEHICLE_TYPE_SOLDIER,
	"ch_heavy_soldier"	: VEHICLE_TYPE_SOLDIER,
	"parachute"		: VEHICLE_TYPE_PARACHUTE,
}

weaponTypeMap = {
	"usrif_m16a2"		: WEAPON_TYPE_ASSAULT,
	"rurif_ak101"		: WEAPON_TYPE_ASSAULT,
	"rurif_ak47"		: WEAPON_TYPE_ASSAULT,
	"usrif_sa80"		: WEAPON_TYPE_ASSAULT,
	"usrif_g3a3"		: WEAPON_TYPE_ASSAULT,
	"usrif_m203"		: WEAPON_TYPE_ASSAULT,
	"rurif_gp30"		: WEAPON_TYPE_ASSAULT,
	"rurif_gp25"		: WEAPON_TYPE_ASSAULT,
	"usrgl_m203"		: WEAPON_TYPE_ASSAULTGRN,
	"rurgl_gp30"		: WEAPON_TYPE_ASSAULTGRN,
	"rurgl_gp25"		: WEAPON_TYPE_ASSAULTGRN,
	"rurrif_ak74u"		: WEAPON_TYPE_CARBINE,
	"usrif_m4"		: WEAPON_TYPE_CARBINE,
	"rurif_ak74u"		: WEAPON_TYPE_CARBINE,
	"chrif_type95"		: WEAPON_TYPE_CARBINE,
	"usrif_g36c"		: WEAPON_TYPE_CARBINE,
	"uslmg_m249saw"		: WEAPON_TYPE_LMG,
	"rulmg_rpk74"		: WEAPON_TYPE_LMG,
	"chlmg_type95"		: WEAPON_TYPE_LMG,
	"rulmg_pkm"		: WEAPON_TYPE_LMG,
	"usrif_m24"		: WEAPON_TYPE_SNIPER,
	"rurif_dragunov"	: WEAPON_TYPE_SNIPER,
	"chsni_type88"		: WEAPON_TYPE_SNIPER,
	"ussni_m82a1"		: WEAPON_TYPE_SNIPER,
	"ussni_m95_barret"	: WEAPON_TYPE_SNIPER,
	"uspis_92fs"		: WEAPON_TYPE_PISTOL,
	"uspis_92fs_silencer"	: WEAPON_TYPE_PISTOL,
	"rupis_baghira"		: WEAPON_TYPE_PISTOL,
	"rupis_baghira_silencer": WEAPON_TYPE_PISTOL,
	"chpis_qsz92"		: WEAPON_TYPE_PISTOL,
	"chpis_qsz92_silencer"	: WEAPON_TYPE_PISTOL,
	"usatp_predator"	: WEAPON_TYPE_ATAA,
	"chat_eryx"		: WEAPON_TYPE_ATAA,
	"usrif_mp5_a3"		: WEAPON_TYPE_SMG,
	"rurif_bizon"		: WEAPON_TYPE_SMG,
	"chrif_type85"		: WEAPON_TYPE_SMG,
	"usrif_remington11-87"	: WEAPON_TYPE_SHOTGUN,
	"rusht_saiga12"		: WEAPON_TYPE_SHOTGUN,
	"chsht_norinco982"	: WEAPON_TYPE_SHOTGUN,
	"chsht_protecta"	: WEAPON_TYPE_SHOTGUN,
	"ussht_jackhammer"	: WEAPON_TYPE_SHOTGUN,
	"kni_knife"		: WEAPON_TYPE_KNIFE,
	"c4_explosives"		: WEAPON_TYPE_C4,
	"ushgr_m67"		: WEAPON_TYPE_HANDGRENADE,
	"usmin_claymore"	: WEAPON_TYPE_CLAYMORE,
	"defibrillator"		: WEAPON_TYPE_SHOCKPAD,
	"at_mine"		: WEAPON_TYPE_ATMINE,
	"simrad"		: WEAPON_TYPE_TARGETING
}


kitTypeMap = {
	"us_at"		: KIT_TYPE_AT,
	"us_assault"	: KIT_TYPE_ASSAULT,
	"us_engineer"	: KIT_TYPE_ENGINEER,
	"us_medic"	: KIT_TYPE_MEDIC,
	"us_specops"	: KIT_TYPE_SPECOPS,
	"us_support"	: KIT_TYPE_SUPPORT,
	"us_sniper"	: KIT_TYPE_SNIPER,
	"mec_at" 	: KIT_TYPE_AT,
	"mec_assault"	: KIT_TYPE_ASSAULT,
	"mec_engineer"	: KIT_TYPE_ENGINEER,
	"mec_medic"	: KIT_TYPE_MEDIC,
	"mec_specops"	: KIT_TYPE_SPECOPS,
	"mec_support"	: KIT_TYPE_SUPPORT,
	"mec_sniper"	: KIT_TYPE_SNIPER,
	"ch_at" 	: KIT_TYPE_AT,
	"ch_assault"	: KIT_TYPE_ASSAULT,
	"ch_engineer"	: KIT_TYPE_ENGINEER,
	"ch_medic"	: KIT_TYPE_MEDIC,
	"ch_specops"	: KIT_TYPE_SPECOPS,
	"ch_support"	: KIT_TYPE_SUPPORT,
	"ch_sniper"	: KIT_TYPE_SNIPER
}

armyMap = {
	"us"		: ARMY_USA,
	"mec"		: ARMY_MEC,
	"ch"		: ARMY_CHINESE
}

mapMap = {
	"kubra_dam"		: "0",
	"mashtuur_city"		: "1",
	"operation_clean_sweep" : "2",
	"zatar_wetlands"	: "3",
	"strike_at_karkand"	: "4",
	"sharqi_peninsula"	: "5",
	"gulf_of_oman"		: "6",
	"daqing_oilfields"	: "100",
	"dalian_plant"		: "101",
	"dragon_valley"		: "102",
	"fushe_pass"		: "103",
	"hingan_hills"		: "104",
	"songhua_stalemate"	: "105",
}
UNKNOWN_MAP = 99

gameModeMap = {
	"gpm_cq"		: 0,
	"gpm_sl"		: 1,
}
UNKNOWN_GAMEMODE = 99


def getVehicleType(templateName):
	try:
		vehicleType = vehicleTypeMap[string.lower(templateName)]
	except KeyError:
		#if g_debug: print "Enter: Vehicle %s not registered for stats." % templateName
		return VEHICLE_TYPE_UNKNOWN
	
	return vehicleType
	
def getWeaponType(templateName):
	try:
		weaponType = weaponTypeMap[string.lower(templateName)]
	except KeyError:
		#if g_debug: print "Enter: Weapon %s not registered for stats." % templateName
		return WEAPON_TYPE_UNKNOWN
	
	return weaponType	
	
def getKitType(templateName):	
	try:
		kitType = kitTypeMap[string.lower(templateName)]
	except KeyError:
		#if g_debug: print "Enter: Kit %s not registered for stats." % templateName
		return KIT_TYPE_UNKNOWN
	
	return kitType	
	
def getArmy(templateName):
	try:
		army = armyMap[string.lower(templateName)]
	except KeyError:
		return ARMY_UNKNOWN
	
	return army

def getMapId(mapName):
	try:
		mapId = mapMap[string.lower(mapName)]
	except KeyError:
		return UNKNOWN_MAP
	
	return mapId

def getGameModeId(gameMode):
	try:
		gameModeId = gameModeMap[string.lower(gameMode)]
	except KeyError:
		return UNKNOWN_GAMEMODE
	
	return gameModeId

def getRootParent(obj):
	parent = obj.getParent()
	
	if parent == None:
		return obj
		
	return getRootParent(parent)


if g_debug: print "Stat constants loaded"






import host
import bf2.PlayerManager
import bf2.GameLogic
from constants import *
from bf2 import g_debug
from bf2.stats.stats import getStatsMap


def init():
	host.registerHandler('ConsoleSendCommand', onSendCommand)
	
	if g_debug: print "End of round module initialized."


def onSendCommand(command, args):
	#if g_debug: print "command:", command, " args:", args
	if string.lower(command) == "eor":
		for p in bf2.playerManager.getPlayers():
			bf2.stats.stats.finalizePlayer(p)

		invoke()
	
def invoke():
	if g_debug: print "Invoked end-of-round data-send"

	# collect needed stats
	e = {}
	
	statsMap = getStatsMap()
	
	# find top player in different categories
	for sp in statsMap.itervalues():
		for k in range(0, NUM_KIT_TYPES + 1):
			if k in sp.kits and sp.kits[k].timeInObject > 0:
				findTop(e, "sk" + str(k), "skn" + str(k), sp.kits[k].score, sp.name)

		for v in range(0, NUM_VEHICLE_TYPES + 1):
			if v in sp.vehicles and sp.vehicles[v].timeInObject > 0:
				findTop(e, "sv" + str(v), "svn" + str(v), sp.vehicles[v].score, sp.name)

		findTop(e, "ts", "tsn", sp.teamScore, sp.name)
		findTop(e, "ss", "ssn", sp.skillScore, sp.name)
		findTop(e, "cpc", "cpcn", sp.localScore.cpCaptures, sp.name)
		findTop(e, "cpa", "cpan", sp.localScore.cpAssists, sp.name)
		findTop(e, "cpd", "cpdn", sp.localScore.cpDefends, sp.name)
		findTop(e, "ka", "kan", sp.localScore.damageAssists + sp.localScore.targetAssists + sp.localScore.passengerAssists, sp.name)
		findTop(e, "he", "hen", sp.localScore.heals, sp.name)
		findTop(e, "rev", "revn", sp.localScore.revives, sp.name)
		findTop(e, "rsp", "rspn", sp.localScore.ammos, sp.name)
		findTop(e, "rep", "repn", sp.localScore.repairs, sp.name)
		findTop(e, "drs", "drsn", sp.localScore.driverSpecials + sp.localScore.driverAssists, sp.name)
		
	
	# find top-3
	if len(statsMap) > 0:
		sortedPlayers = []
		for sp in statsMap.itervalues():
			sortedPlayers += [((sp.score, sp.skillScore, -sp.deaths), sp)]
	
		sortedPlayers.sort()
		sortedPlayers.reverse()
		
		# stats for top-3 scoring players
		for i in range(3):
			if len(sortedPlayers) <= i:
				break
	
			sp = sortedPlayers[i][1]
			e["np" + str(i)] = sp.name
			e["tsp" + str(i)] = sp.teamScore
			e["ssp" + str(i)] = sp.skillScore
			e["csp" + str(i)] = sp.cmdScore
			e["bfp" + str(i)] = sp.bulletsFired
			e["bhp" + str(i)] = sp.bulletsHit
			for k in range(0, NUM_KIT_TYPES + 1):
				if sp.kits[k].timeInObject > 0:
					e["tk" + str(k) + "p" + str(i)] = int(sp.kits[k].timeInObject)
					
			for v in range(0, NUM_VEHICLE_TYPES + 1):
				if sp.vehicles[v].timeInObject > 0:
					e["tv" + str(v) + "p" + str(i)] = int(sp.vehicles[v].timeInObject)
		
	keyvals = []
	for k in e:
		keyvals.append ("\\".join((k, str(e[k]))))

	dataString = "\\" + "\\".join(keyvals)
	
	if g_debug: print dataString
	host.gl_sendEndOfRoundData(dataString)

	
		
		

def findTop(e, vkey, nkey, value, name):
	if not vkey in e or value > e[vkey]:
		e[vkey] = value
		e[nkey] = name






# fragalyzer log file generator. 
# 
# enable by typing this in the console:
# pythonHost.sendCommand falog 1

# needs to be re-enabled in each round.

import host
import bf2.PlayerManager
import bf2.GameLogic
import fpformat
import datetime
import time
import fpformat
from constants import *
from bf2 import g_debug

logfile = None
fileName = ""


def init():
	host.registerHandler('ConsoleSendCommand', onSendCommand)

	if g_debug: print "Fragalyzer log module initialized."

	
def enable():
	global fileName
	global logfile
	global startTime

	if logfile and not logfile.closed:
		print "Fragalyzer logging already enabled"
		return 
		
	host.registerGameStatusHandler(onGameStatusChanged)
	
	currentDate = datetime.datetime.today()
	dateString = ""
	dateString = time.strftime("%y%m%d_%H%M", currentDate.timetuple())

	if dateString != "":
		fileName = bf2.gameLogic.getModDir() + "/Logs/" + bf2.gameLogic.getMapName() + "_" + dateString + "_faLog.txt"
	else:
		fileName = bf2.gameLogic.getModDir() + "/Logs/" + bf2.gameLogic.getMapName() + "_faLog.txt"
		
	fileName = fileName.replace('/', '\\')
	
	print "log file: ", fileName

	try:
		logfile = file (fileName, 'w')
	except Exception:
		if g_debug: print "Couldnt open fragalyzer logfile: ", fileName
		return
	
	startTime = int(date())
	timeString = str(startTime)
	startDate = time.strftime("%Y.%m.%d,%H:%M", currentDate.timetuple())
	logfile.write("INIT LevelName=" + bf2.gameLogic.getMapName() + " StartTime=" + timeString + " StartDate=" + startDate + " Filename=" + fileName + "\n")
		
	logfile.flush()


	# register events
	host.registerHandler('PlayerKilled', onPlayerKilled)
	host.registerHandler('PlayerDeath', onPlayerDeath)
	host.registerHandler('EnterVehicle', onEnterVehicle)
	host.registerHandler('ExitVehicle', onExitVehicle)
	host.registerHandler('PickupKit', onPickupKit)
	host.registerHandler('DropKit', onDropKit)
	host.registerHandler('ControlPointChangedOwner', onCPStatusChange)
	host.registerHandler('PlayerScore', onPlayerScore)
	host.registerHandler('PlayerSpawn', onPlayerSpawn)

	host.registerHandler('PlayerConnect', onPlayerConnect, 1)

	# Connect already connected players if reinitializing
	for p in bf2.playerManager.getPlayers():
		onPlayerConnect(p)
	
	print "Fragalyzer logging enabled."


class faStat:
	def __init__(self):
		self.enterAt = 0
		self.enterTemplate = None
		self.spawnAt = 0
		
	def copyStats(self, player):
		self.damageAssists = player.score.damageAssists
		self.passengerAssists = player.score.passengerAssists
		self.targetAssists = player.score.targetAssists
		self.revives = player.score.revives
		self.teamDamages = player.score.teamDamages
		self.teamVehicleDamages = player.score.teamVehicleDamages
		self.cpCaptures = player.score.cpCaptures
		self.cpDefends = player.score.cpDefends
		self.cpAssists = player.score.cpAssists
		self.cpNeutralizes = player.score.cpNeutralizes
		self.cpNeutralizeAssists = player.score.cpNeutralizeAssists
		self.suicides = player.score.suicides
		self.kills = player.score.kills
		self.TKs = player.score.TKs

	def getChangedStats(self, player):
		res = []
		if player.score.cpCaptures > self.cpCaptures:
			res += ["cpCaptures"]
		if player.score.cpDefends > self.cpDefends:
			res += ["cpDefends"]
		if player.score.cpAssists > self.cpAssists:
			res += ["cpAssists"]
		if player.score.cpNeutralizes > self.cpNeutralizes:
			res += ["cpNeutralizes"]
		if player.score.cpNeutralizeAssists > self.cpNeutralizeAssists:
			res += ["cpNeutralizeAssists"]
		if player.score.suicides > self.suicides:
			res += ["suicides"]
		if player.score.kills > self.kills:
			res += ["kills"]
		if player.score.TKs > self.TKs:
			res += ["TKs"]
		if player.score.damageAssists > self.damageAssists:
			res += ["damageAssists"]
		if player.score.passengerAssists > self.passengerAssists:
			res += ["passengerAssists"]
		if player.score.targetAssists > self.targetAssists:
			res += ["targetAssists"]
		if player.score.revives > self.revives:
			res += ["revives"]
		if player.score.teamDamages > self.teamDamages:
			res += ["teamDamages"]
		if player.score.teamVehicleDamages > self.teamVehicleDamages:
			res += ["teamVehicleDamages"]
		
			
		return res
		

def onPlayerConnect(player):
	player.fa = faStat()	
	player.fa.enterAt = date()
	if player.isAlive():
		player.fa.spawnAt = date()
	vehicle = player.getVehicle()
	onEnterVehicle(player, vehicle)
	kit = player.getKit()
	if kit:
		onPickupKit(player, kit)
		
	player.fa.copyStats(player)

	
def disable():
	if logfile:
		timeString = str(int(date()))
		logfile.write("DISABLE LevelName=" + bf2.gameLogic.getMapName() + " EndTime=" + timeString + "\n")
		logfile.close()
		print "Fragalyzer logging disabled."
	else:
		print "Fragalyzer logging was already disabled."



def onGameStatusChanged(status):
	if status == bf2.GameStatus.Playing:
		pass

	elif status == bf2.GameStatus.EndGame:
		disable()
		
	
def getPosStr(orgPos):
	worldSize = bf2.gameLogic.getWorldSize();
	scale = [512.0 / worldSize[0], 1, 512.0 / worldSize[1]]
	pos = [orgPos[0] * scale[0], orgPos[1] * scale[1], orgPos[2] * scale[2]]
	res = str(fpformat.fix(pos[0], 3)) + "," + str(fpformat.fix(pos[1], 3)) + "," + str(fpformat.fix(pos[2], 3))
	return res


def onSendCommand(command, args):
	if string.lower(command) == "falog":
		if len(args) > 0:
			if args[0] == "1":
				enable()
			elif args[0] == "0":
				disable()
		

def date():
	return host.timer_getWallTime()

def wallString():
	return str(int(host.timer_getWallTime()) - startTime)

def onEnterVehicle(player, vehicle, freeSoldier = False):
	if player == None: return
	rootVehicle = getRootParent(vehicle)
	if rootVehicle.templateName == 'MultiPlayerFreeCamera':
		return
		
	vehicleType = getVehicleType(rootVehicle.templateName)

	if vehicleType == VEHICLE_TYPE_SOLDIER:
		pass
	else:
		timeString = wallString()
		playerTeam = str(player.getTeam())
		logfile.write("ENTER PlayerName=" + player.getName() + " PlayerTeam=" + playerTeam + " VehicleName=" + rootVehicle.templateName + " Time=" + timeString + "\n")
		player.fa.enterAt = date()
		player.fa.enterTemplate = rootVehicle.templateName
		

	logfile.flush()

	return

def onPlayerSpawn(player, soldier):
	pass

def onExitVehicle(player, vehicle):
	if player == None: return
	rootVehicle = getRootParent(vehicle)
	vehicleType = getVehicleType(rootVehicle.templateName)
	playerTeam = str(player.getTeam())

	if vehicleType == VEHICLE_TYPE_SOLDIER:
		pass
	else:
		timeInVehicle = 0
		if player.fa.enterTemplate == rootVehicle.templateName:
			timeInVehicle = date() - player.fa.enterAt
		timeString = wallString()
		logfile.write("EXIT PlayerName=" + player.getName() + " PlayerTeam=" + playerTeam + " VehicleName=" + rootVehicle.templateName + " VehicleTime="\
		 + str(fpformat.fix(timeInVehicle, 1)) + " Time=" + timeString + "\n")
		
	player.fa.enterAt = 0
	
	logfile.flush()
	return

def onPickupKit(player, kit):
	timeString = wallString()
	playerSpawnTimePickupDiff = str(int(date())-int(player.stats.spawnedAt))
	playerTeam = str(player.getTeam())
	logfile.write("PICKUPKIT PlayerName=" + player.getName() + " PlayerTeam=" + playerTeam + " PlayerKit=" + kit.templateName + " PickupSpawnDiff=" + playerSpawnTimePickupDiff + " Time=" + timeString + "\n")
	player.fa.spawnAt = date()
	player.lastKitTemplateName = kit.templateName
	logfile.flush()
	
def onDropKit(player, kit):
	timeInVehicle = 0
	if player.fa.spawnAt != 0:
		timeInVehicle = date() - player.fa.spawnAt 
	timeString = wallString()
	playerTeam = str(player.getTeam())
	logfile.write("DROPKIT PlayerName=" + player.getName() + " PlayerTeam=" + playerTeam + " PlayerKit=" + kit.templateName + " PlayerKitTime=" + str(fpformat.fix(timeInVehicle, 1)) + " Time=" + timeString + "\n")
	logfile.flush()
	return

def onPlayerKilled(victim, attacker, weapon, assists, object):
	victimKitName = victim.lastKitTemplateName
	victimVehicle = victim.getVehicle()
	victimRootVehicle = getRootParent(victimVehicle)
	victimVehicleType = getVehicleType(victimRootVehicle.templateName)
	victimName = victim.getName()
	victimTeam = str(victim.getTeam())

	if attacker:
		attackerKitName = attacker.lastKitTemplateName	
		attackerVehicle = attacker.getVehicle()
		attackerRootVehicle = getRootParent(attackerVehicle)
		attackerVehicleType = getVehicleType(attackerRootVehicle.templateName)
		attackerName = attacker.getName()
		attackerTeam = str(attacker.getTeam())
	else:
		attackerKitName = None
		attackerVehicle = None
		attackerRootVehicle = None
		attackerVehicleType = VEHICLE_TYPE_UNKNOWN
		
	logfile.write("KILL")
	if attacker:
		logfile.write(" AttackerName=" + attackerName + " AttackerTeam=" + attackerTeam + " AttackerPos=" + getPosStr(attackerVehicle.getPosition()))
	if victimVehicle != None:
		logfile.write(" VictimName=" + victimName + " VictimTeam=" + victimTeam + " VictimPos=" + getPosStr(victimVehicle.getPosition()))
		if victimKitName != None:
			logfile.write(" VictimKit=" + victimKitName)
		if victimVehicle != None and (attackerVehicleType != VEHICLE_TYPE_SOLDIER):
			logfile.write(" VictimVehicle=" + victimRootVehicle.templateName)

	if attackerKitName != None:
		logfile.write(" AttackerKit=" + attackerKitName)
	if attackerVehicle != None and (attackerVehicleType != VEHICLE_TYPE_SOLDIER):
		logfile.write(" AttackerVehicle=" + attackerRootVehicle.templateName)
		
	if weapon != None:
		logfile.write(" AttackerWeapon=" + weapon.templateName)

	timeString = wallString()	
	logfile.write(" Time=" + timeString + "\n")
	logfile.flush()

def onPlayerDeath(victim, vehicle):

	# dump accuracy stats on death (can't invoke on each shot being fired)
	tempFireMap = {}
	bulletsHit = victim.score.bulletsGivingDamage
	for b in bulletsHit:
		templateName = b[0]
		nr = b[1]
		tempFireMap[templateName] = nr

	bulletsFired = victim.score.bulletsFired
	if g_debug: print "bf: ", len(bulletsFired)
	for b in bulletsFired:
		templateName = b[0]
		fired = b[1]
		hits = 0
		if templateName in tempFireMap:
			hits = tempFireMap[templateName]
		timeString = wallString()
		logfile.write("FIRED PlayerName=" + victim.getName() + " Weapon=" + templateName + " ShotsFired=" + str(fired) + " ShotsHit=" + str(hits) + " Time=" + timeString + "\n")

	logfile.flush()


def onCPStatusChange(cp, attackingTeam):
	position = cp.getPosition()
	if (cp.cp_getParam('team') == 0):
		captureType = "team"
	else:
		if attackingTeam == 0:
			return
		captureType = "neutral"
	
	timeString = wallString()
	logfile.write("CAPTURE ControlPointID=" + cp.getTemplateProperty('controlPointId') + " CaptureType=" + captureType\
	 + " CaptureTeam=" + str(attackingTeam) + " CapturePointPos=" + getPosStr(cp.getPosition()) + " Time=" + timeString + "\n")
	 
	logfile.flush()
	
	 
def onPlayerScore(player, difference):
	if player != None:
		playerKitName = player.lastKitTemplateName
		playerVeh = player.getVehicle()
		playerRootVeh = getRootParent(playerVeh)
		playerVehName = playerRootVeh.templateName
		playerVehType = getVehicleType(playerRootVeh.templateName)
		timeString = wallString()
		
		# figure out score type
		scoreTypeList = player.fa.getChangedStats(player)
		player.fa.copyStats(player)
		if len(scoreTypeList):
			scoreType = scoreTypeList[0]
		else:
			scoreType = "Unknown"
			
		logfile.write("SCORE ScoreDiff=" + str(difference) + " PlayerName=" + player.getName() + " PlayerTeam=" + str(player.getTeam()) + " PlayerKit=" + playerKitName)
		if (playerVeh != None) and (playerVehType != VEHICLE_TYPE_SOLDIER):
			logfile.write(" PlayerVehicle=" + playerVehName)
		logfile.write(" PlayerPos=" + getPosStr(playerVeh.getPosition()) + " Time=" + timeString + " Scoretype=" + scoreType + "\n")

	logfile.flush()





# rank upgrades

import host
import bf2.PlayerManager
import bf2.Timer
from bf2.stats.constants import *
from bf2 import g_debug

def init():
	# Events
	host.registerHandler('ConsoleSendCommand', onSendCommand)

	if bf2.serverSettings.getUseGlobalRank():
	 	host.registerHandler('PlayerConnect', onPlayerConnect, 1)
		host.registerHandler('PlayerStatsResponse', onStatsResponse, 1)

	host.registerGameStatusHandler(onGameStatusChanged)
	
	# Connect already connected players if reinitializing
	for p in bf2.playerManager.getPlayers():
		onPlayerConnect(p)

	if g_debug: print "Rank module initialized"


def onSendCommand(command, args):
	if command == "giverank":
		pId = int(args[0])
		rank = int(args[1])
		
		player = bf2.playerManager.getPlayerByIndex(pId)
		awardRank(player, rank)
	
	#jlo: temp for laedre! remove!
	elif command == "setname":
		pId = int(args[0])
		name = args[1]
		player = bf2.playerManager.getPlayerByIndex(pId)
		player.setName(name)
		

def onGameStatusChanged(status):
	if status == bf2.GameStatus.Playing:
		#updateTimer = bf2.Timer(onUpdate, 20)
		#updateTimer.setRecurring(20)
		pass
	else:
		if g_debug: print "Destroyed timer"
		#updateTimer.destroy()


def onUpdate(data):
	#if g_debug: print "update rank"
	for p in bf2.playerManager.getPlayers():
		if p.isAlive():
			checkRank(p)




### Event hooks

def onPlayerConnect(player):
	id = player.index
	if player.score.rank == -1:
		player.score.rank = 0
	
	# request rank
	if bf2.serverSettings.getUseGlobalRank():
		if player.getProfileId() > 2000:		
			success = host.pers_plrRequestStats(player.index, 1, "&info=rank")
		else:
			if g_debug: print "Player %d had no profile id, can't request rank" % player.index
			
	
	if g_debug: print "Added player %d to rank checking" % (player.index)
	
	
def onStatsResponse(succeeded, player, stats):
	if player == None:
		playerIndex = "unknown"
	else:
		playerIndex = player.index

	if not "rank" in stats:
		if g_debug: print "rank not found, aborting"
		return

	if g_debug: print "Rank received for player ", playerIndex, ":", host.pers_getStatsKeyVal("rank")
	if not player: return
	
	
	if not player: return
	
	if not "rank" in stats:
		if g_debug: print "Rank not found in stats response"
	else:
		value = host.pers_getStatsKeyVal("rank")
		if g_debug: print "Player %s Rank:%s" % (player.index, int(value))
		player.score.rank = int(value)
		player.stats.rank = int(value)
		
		
		
		import host
import bf2.PlayerManager
import fpformat
from constants import *
from bf2 import g_debug


	
roundArmies = [None, None, None]

playerConnectionOrderIterator = 0
def getPlayerConnectionOrderIterator():
	global playerConnectionOrderIterator
	return playerConnectionOrderIterator

def setPlayerConnectionOrderIterator(value):
	global playerConnectionOrderIterator
	playerConnectionOrderIterator = value


sessionPlayerStatsMap = {}
def getStatsMap():
	global sessionPlayerStatsMap
	return sessionPlayerStatsMap

def setStatsMap(map):
	global sessionPlayerStatsMap
	sessionPlayerStatsMap = map



def init():
	host.registerHandler('PlayerConnect', onPlayerConnect, 1)
	host.registerHandler('PlayerDisconnect', onPlayerDisconnect, 1)
	host.registerHandler('ConsoleSendCommand', onSendCommand, 1)
	host.registerHandler('Reset', onReset, 1)

	host.registerGameStatusHandler(onGameStatusChanged)
	
	# connecting up to gamespy is done in gameserver creation if GSRanked is set.
	
	if g_debug: print "Persistant stats module initialized."
	
	

def onGameStatusChanged(status):
	if status == bf2.GameStatus.Playing:

		# todo: ignore if last state was GSPaused

		# find highest player still connected
		highestPid = -1
		for pid in sessionPlayerStatsMap:
			if pid > highestPid:
				highestPid = pid
		
		global playerConnectionOrderIterator
		playerConnectionOrderIterator = highestPid + 1
		if g_debug: print "Reset orderiterator to %d based on highest pid kept" % playerConnectionOrderIterator

		# Reconnect players
		if len(sessionPlayerStatsMap) == 0:
			print "Reloading players"
			for p in bf2.playerManager.getPlayers():
				onPlayerConnect(p)
	
		global army
		roundArmies[1] = getArmy(bf2.gameLogic.getTeamName(1))
		roundArmies[2] = getArmy(bf2.gameLogic.getTeamName(2))

		# All other hooks	
		host.registerHandler('PlayerKilled', onPlayerKilled2)
		host.registerHandler('PlayerDeath', onPlayerDeath)
		host.registerHandler('EnterVehicle', onEnterVehicle)
		host.registerHandler('ExitVehicle', onExitVehicle)
		host.registerHandler('PickupKit', onPickupKit)
		host.registerHandler('DropKit', onDropKit)
		host.registerHandler('PlayerChangedSquad', onPlayerChangedSquad)
		host.registerHandler('ChangedCommander', onChangedCommander)
		host.registerHandler('ChangedSquadLeader', onChangedSquadLeader)
		host.registerHandler('PlayerChangeWeapon', onPlayerChangeWeapon)
		host.registerHandler('PlayerBanned', onPlayerBanned)
		host.registerHandler('PlayerKicked', onPlayerKicked)
		host.registerHandler('PlayerSpawn', onPlayerSpawn)
		host.registerHandler('PlayerScore', onPlayerScore)

		for s in sessionPlayerStatsMap.itervalues():
			s.reset()

		for p in bf2.playerManager.getPlayers():
			p.stats.reinit(p)
			p.stats.wasHereAtStart = 1
			
		bf2.playerManager.enableScoreEvents()


	elif status == bf2.GameStatus.EndGame:

		if g_debug: print "endgame"
		# finalize stats and send snapshot
		for p in bf2.playerManager.getPlayers():
			p.stats.wasHereAtEnd = 1
			finalizePlayer(p)
			
		# show end-of-round information
		bf2.stats.endofround.invoke()
		
		# if not ranked, clean out stats vectors
		if not host.ss_getParam('ranked'):
			playerConnectionOrderIterator = 0
			sessionPlayerStatsMap.clear()


		
	
	
def onReset(data):
	for s in sessionPlayerStatsMap.itervalues():
		s.reset()

	for p in bf2.playerManager.getPlayers():
		p.stats.reinit(p)
		p.stats.wasHereAtStart = 1
	
	
	
	



	
	
class PlayerStat: 
	def __init__(self, player):
		self.profileId = player.getProfileId()
		self.playerId = player.index
		self.id = self.playerId
		self.connectionOrderNr = 0
		self.rank = 0
		
		self.reinit(player)
		self.reset()
		
	

	def reinit(self, player):
		self.name = player.getName()
		self.ipaddr = player.getAddress()
		self.localScore = player.score
		
	
	def reset(self):
		self.connectAt = date()
		self.timeOnLine = 0
		
		self.score 	= 0
		self.cmdScore 	= 0
		self.teamScore 	= 0
		self.skillScore = 0
		self.kills 	= 0
		self.teamkills 	= 0
		self.deaths 	= 0
				
		self.vehicles = {}
		for v in range(0, NUM_VEHICLE_TYPES + 1):
			if not v in self.vehicles:
				self.vehicles[v] = VehicleStat(v)
			else:
				self.vehicles[v].reset()
	
		self.weapons = {}
		for w in range(0, NUM_WEAPON_TYPES + 1):
			if not w in self.weapons:
				self.weapons[w] = WeaponStat(w)
			else:
				self.weapons[w].reset()
	
		self.kits = {}
		for k in range(0, NUM_KIT_TYPES + 1):
			if not k in self.kits:
				self.kits[k] = KitStat(k)
			else:			
				self.kits[k].reset()
	
		self.killedByPlayer = {}
		self.killedPlayer = {}

		self.team = 0

		self.localScore.reset()
		
		self.bulletsFired = 0
		self.bulletsHit = 0

		self.currentKillStreak = 0
		self.longestKillStreak = 0
		self.currentDeathStreak = 0
		self.longestDeathStreak = 0
		self.wasHereAtStart = 0
		self.wasHereAtEnd = 0
		self.complete = 0
		self.medals = None
		
		self.spawnedTeam = 3
		self.spawnedAt = 0
		self.becameCmdAt = 0
		self.becameSqlAt = 0
		self.joinedSquadAt = 0
		self.rawTimePlayed = 0
		self.rawTimeAsCmd = 0
		self.rawTimeAsSql = 0
		self.rawTimeInSquad = 0
		
		self.timesBanned = 0
		self.timesKicked = 0
		
		self.timeAsArmy = {}
		for a in range(0, NUM_ARMIES + 1):
			self.timeAsArmy[a] = 0
			
		self.currentWeaponType = NUM_WEAPON_TYPES

	def __getattr__(self, name):
		if name in self.__dict__: return self.__dict__[name]
		elif name == 'timePlayed':
			if self.spawnedAt:
				timeDiff = date() - self.spawnedAt
				self.rawTimePlayed += timeDiff
				self.timeAsArmy[roundArmies[self.spawnedTeam]] += timeDiff
				self.spawnedAt = date()
			return self.rawTimePlayed
		elif name == 'timeAsCmd':
			if self.becameCmdAt:
				self.rawTimeAsCmd += date() - self.becameCmdAt 
				self.becameCmdAt = date()
			return self.rawTimeAsCmd
		elif name == 'timeAsSql':
			if self.becameSqlAt:
				self.rawTimeAsSql += date() - self.becameSqlAt 
				self.becameSqlAt = date()
			return self.rawTimeAsSql
		elif name == 'timeInSquad':
			if self.joinedSquadAt:
				self.rawTimeInSquad += date() - self.joinedSquadAt 
				self.joinedSquadAt = date()
			return self.rawTimeInSquad
		elif name == 'accuracy':
			if self.bulletsFired == 0:
				return 0
			else:
				return 1.0 * self.bulletsHit / self.bulletsFired
		else:
			raise AttributeError, name
			
			
	# when same player rejoins server
	def reconnect(self, player):
		self.connectAt = date()
		self.ipaddr = player.getAddress()
		
		bf2.playerManager.disableScoreEvents()
		
		print "Reattaching score object from old dead player %d to new player %d" % (self.localScore.index, player.index)

		player.score = self.localScore
		player.score.index = player.index

		player.score.score 	= self.score
		player.score.cmdScore 	= self.cmdScore
		player.score.rplScore 	= self.teamScore
		player.score.skillScore = self.skillScore
		player.score.kills 	= self.kills
		player.score.TKs 	= self.teamkills
		player.score.deaths 	= self.deaths

		player.score.rank	= self.rank

		bf2.playerManager.enableScoreEvents()
		
	# calculate final stats values for this player (disconnected or end of round)
	def finalize(self, player):
		self.copyPlayerData(player)
		
		if self.currentWeaponType != NUM_WEAPON_TYPES:
			self.weapons[self.currentWeaponType].exit(player)
			self.currentWeaponType = NUM_WEAPON_TYPES

		stopSpawned(player)	
		stopInSquad(player)
		stopAsSql(player)
		stopAsCmd(player)
		
		if self.wasHereAtStart == 1 and self.wasHereAtEnd == 1:
			self.complete = 1
			
		# sum up vehicles & kits
		collectBulletsFired(player)
		finalizeBulletsFired(player)
			
		for v in player.stats.vehicles.itervalues():
			if v.enterAt != 0: v.exit(player)
		for v in player.stats.kits.itervalues():
			if v.enterAt != 0: v.exit(player)
		for v in player.stats.weapons.itervalues():
			if v.enterAt != 0: v.exit(player)

			
			
	# copy data to player-stats, as player might not be awailable after this
	def copyPlayerData(self, player):
		self.timeOnLine += date() - self.connectAt

		self.localScore = player.score
		
		self.score 	= player.score.score
		self.cmdScore 	= player.score.cmdScore	
		self.teamScore 	= player.score.rplScore
		self.skillScore = player.score.skillScore

		if self.score < 0: 	self.score = 0
		if self.cmdScore < 0: 	self.cmdScore = 0
		if self.teamScore < 0: 	self.teamScore = 0
		if self.skillScore < 0: self.skillScore = 0
				
		self.kills 	= player.score.kills
		self.teamkills 	= player.score.TKs
		self.deaths 	= player.score.deaths

		self.rank = player.score.rank
		self.army = roundArmies[player.getTeam()]
		self.team = player.getTeam()
		
		if host.ss_getParam('ranked'):
			if hasattr(player, 'medals'):
				self.medals = player.medals
			else:
				if g_debug: print "Player had no medal stats. pid=", player.index
			
	


			
		
		
class ObjectStat: 
	def __init__(self, type):
		self.reset()
		self.type = type
	
	def reset(self):	
		# reset all non-global
		self.kills = 0
		self.killedBy = 0
		self.rawTimeInObject = 0
		self.deaths = 0
		self.score = 0
		self.bulletsFired = 0
		self.bulletsFiredTemp = 0
		self.bulletsHit = 0
		self.bulletsHitTemp = 0
		self.enterAt = 0
		self.enterScore = 0	
		
	def enter(self, player):
		self.enterAt = date()
		self.enterScore = player.score.score
	
	def exit(self, player):
		if self.enterAt == 0: return
		time = self.timeInObject
		self.enterAt = 0
		
		self.score += player.score.score - self.enterScore
		self.enterScore = 0 
		
	def __getattr__(self, name):
		if name in self.__dict__: return self.__dict__[name]
		elif name == 'timeInObject' or name == 'rtime':
			if self.enterAt:
				self.rawTimeInObject += date() - self.enterAt
				self.enterAt = date()
			return self.rawTimeInObject
		elif name == 'accuracy':
			if self.bulletsFired == 0:
				return 0
			else:
				return 1.0 * self.bulletsHit / self.bulletsFired
		else:
			raise AttributeError, name
		



class VehicleStat(ObjectStat): 
	def __init__(self, type):
		ObjectStat.__init__(self, type)
		self.reset()
	
	def reset(self):	
		ObjectStat.reset(self)
		self.roadKills = 0
		

class KitStat(ObjectStat):
	def __init__(self, type):
		ObjectStat.__init__(self, type)
		self.reset()
	
	def reset(self):
		ObjectStat.reset(self)


class WeaponStat(ObjectStat):
	def __init__(self, type):
		ObjectStat.__init__(self, type)
		self.reset()
		
	def reset(self):
		ObjectStat.reset(self)
		
	def enter(self, player):
		if player.stats.currentWeaponType != NUM_WEAPON_TYPES:
			player.stats.weapons[player.stats.currentWeaponType].exit(player)
		player.stats.currentWeaponType = self.type

		#if g_debug: print "enter weapon: ", self.type, " time:", date()
		ObjectStat.enter(self, player)
	
	def exit(self,player):
		time = date() - self.enterAt

		ObjectStat.exit(self, player)
		#if g_debug: print "exited weapon: ", self.type, " time:", date()
	

	
	
def date():
	return host.timer_getWallTime()	
	

def finalizePlayer(player):
	player.stats.finalize(player)
	if g_debug: print "Player %d disconnected using %d time." % (player.index, player.stats.timeOnLine)


def onPlayerConnect(player):
	# see if player already has a record
	player.stats = None
	connectingProfileId = player.getProfileId()
	for stats in sessionPlayerStatsMap.itervalues():
		if connectingProfileId > 0 and connectingProfileId == stats.profileId:
			print "Found old player record, profileId ", stats.profileId
			player.stats = stats
			player.stats.reconnect(player)
	
	if not player.stats:
	
		print "Creating new record for player profileId ", connectingProfileId
		
		# add stats record
		global playerConnectionOrderIterator
		id = playerConnectionOrderIterator
		
		newPlayerStats = PlayerStat(player)
		
		sessionPlayerStatsMap[id] = newPlayerStats
		player.stats = sessionPlayerStatsMap[id]
		
		player.stats.connectionOrderNr = playerConnectionOrderIterator
	
		# temp hack for faking a profile id
		if player.stats.profileId == 0:
			if g_debug: print "No profile id, faking 1000-based"
			player.stats.profileId = 1000 + player.stats.connectionOrderNr
		else:
			if g_debug: print "Player profile id: ", player.stats.profileId

		playerConnectionOrderIterator += 1
		
	player.score.rank = player.stats.rank
	
	print "Player id=%d, name='%s', ordinal=%d connected at time %s" % \
		(player.index, player.getName(), player.stats.connectionOrderNr, str(player.stats.connectAt))


def onSendCommand(command, args):
	if command == "endgame":
		host.sgl_endGame(0, 0)	
	elif command == "snap":
		for p in bf2.playerManager.getPlayers():
			p.stats.copyPlayerData(p)
			
		print bf2.stats.snapshot.getSnapShot()
	elif command == "geta":
		player = bf2.playerManager.getPlayerByIndex(1)
		player.stats = None
		connectingProfileId = player.getProfileId()
		for stats in sessionPlayerStatsMap.itervalues():
			if connectingProfileId > 0 and connectingProfileId == stats.profileId:
				print "Found old player record, profileId ", stats.profileId
				player.stats = stats
				player.stats.reconnect(player)
	
		if not player.stats:
			print "hej"
		else:
			print "hej2"
	elif command == "eor":
		# show end-of-round information
		bf2.stats.endofround.invoke()

	elif command == "say":
		bf2.gameLogic.sendServerMessage(0, "hello")
		
		
		



	
	
def onPlayerDisconnect(player):
	#Store timers
	finalizePlayer(player)






def onEnterVehicle(player, vehicle, freeSoldier = False):

	#print "enter vehicle:", vehicle.templateName, player.getVehicle().templateName

	if player == None: return

	vehicleType = getVehicleType(vehicle.templateName)
	if vehicleType != VEHICLE_TYPE_SOLDIER:
		rootVehicle = getRootParent(vehicle)
		vehicleType = getVehicleType(rootVehicle.templateName)
	else: rootVehicle = vehicle
	
	if g_debug: print "Player %d entered vehicle with name %s type %s" % (player.index, rootVehicle.templateName, vehicleType)
	#if vehicleType == VEHICLE_TYPE_UNKNOWN: return

	if vehicleType != VEHICLE_TYPE_SOLDIER:
		for w in player.stats.weapons.itervalues():
			w.exit(player)

	weapon = player.getPrimaryWeapon()
	if weapon:
		weaponType = getWeaponType(weapon.templateName)
		player.stats.weapons[weaponType].enter(player)

	if not vehicleType in player.stats.vehicles:
		player.stats.vehicles[vehicleType] = VehicleStat()
		
	player.stats.vehicles[vehicleType].enter(player)
	if vehicleType != VEHICLE_TYPE_UNKNOWN:
		player.stats.lastVehicleType = vehicleType
		
	weapon = player.getPrimaryWeapon()
	if weapon:
		player.stats.lastWeaponType = getWeaponType(weapon.templateName)
	
	collectBulletsFired(player)
	



def onExitVehicle(player, vehicle):
	
	#print "exit vehicle:", vehicle.templateName
	
	vehicleType = getVehicleType(vehicle.templateName)
	if vehicleType != VEHICLE_TYPE_SOLDIER:
		rootVehicle = getRootParent(vehicle)
		vehicleType = getVehicleType(rootVehicle.templateName)
		
		# keep track of last driver, for road kill scoring purposes
		if rootVehicle == vehicle:
			vehicle.lastDrivingPlayerIndex = player.index
		
	else: rootVehicle = vehicle

	#if vehicleType == VEHICLE_TYPE_UNKNOWN: return

	weapon = player.getPrimaryWeapon()
	if weapon:
		weaponType = getWeaponType(weapon.templateName)
		player.stats.weapons[weaponType].enter(player)
	
	player.stats.vehicles[vehicleType].exit(player)

	weapon = player.getPrimaryWeapon()
	if weapon:
		player.stats.lastWeaponType = getWeaponType(weapon.templateName)

	collectBulletsFired(player)
	


def onPlayerSpawn(player, soldier):
	#if g_debug: print "Player spawned squad:%d,%d sql:%d,%d cmd:%d,%d" % (player.getSquadId(), player.stats.timeInSquad,\
	#player.isSquadLeader(), player.stats.timeAsSql, player.isCommander(), player.stats.timeAsCommander)

	startSpawned(player)
	if player.getSquadId() != 0: startInSquad(player)
	if player.isSquadLeader(): startAsSql(player)		
	if player.isCommander(): startAsCmd(player)

	onEnterVehicle(player, soldier)
	player.soldier = soldier
		
	

def onPickupKit(player, kit):
	kitType = getKitType(kit.templateName)

	if not kitType in player.stats.kits:
		player.stats.kits[kitType] = KitStat()

	player.stats.kits[kitType].enter(player)
	player.stats.lastKitType = kitType
	
	weapon = player.getPrimaryWeapon()
	if weapon:
		player.stats.lastWeaponType = getWeaponType(weapon.templateName)

	
def onDropKit(player, kit):
	kitType = getKitType(kit.templateName)
	player.stats.kits[kitType].exit(player)
	
	for w in player.stats.weapons.itervalues():
		w.exit(player)
	
	#if g_debug: print "dropkit ", kitType
	collectBulletsFired(player)

def onPlayerChangeWeapon(player, oldWeapon, newWeapon):
	if oldWeapon:
		oldWeaponType = getWeaponType(oldWeapon.templateName)
		player.stats.weapons[oldWeaponType].exit(player)
		
	if newWeapon:
		newWeaponType = getWeaponType(newWeapon.templateName)
		player.stats.weapons[newWeaponType].enter(player)
		player.stats.lastWeaponType = newWeaponType
		

def onPlayerKilled2(victim, attacker, weapon, assists, object):

	# check if killed by vehicle in motion
	killedByEmptyVehicle = False
	if attacker == None and weapon == None and object != None:
		if hasattr(object, 'lastDrivingPlayerIndex'):
			attacker = bf2.playerManager.getPlayerByIndex(object.lastDrivingPlayerIndex)
			killedByEmptyVehicle = True

	# killed by enemy
	if attacker != None:# and attacker.getTeam() != victim.getTeam():

		# no kill stats for teamkills / suicides!
		if attacker.getTeam() != victim.getTeam():
	
			# streaks
			attacker.stats.currentKillStreak += 1
			if attacker.stats.currentKillStreak > attacker.stats.longestKillStreak:
				attacker.stats.longestKillStreak = attacker.stats.currentKillStreak
	
			attacker.stats.currentDeathStreak = 0  # this ends the current death streak

			# killedBy
			if attacker != None:
				if not victim.stats.connectionOrderNr in attacker.stats.killedPlayer:
					attacker.stats.killedPlayer[victim.stats.connectionOrderNr] = 0
				attacker.stats.killedPlayer[victim.stats.connectionOrderNr] += 1
			
				if not attacker.stats.connectionOrderNr in victim.stats.killedByPlayer:
					victim.stats.killedByPlayer[attacker.stats.connectionOrderNr] = 0
				victim.stats.killedByPlayer[attacker.stats.connectionOrderNr] += 1
		
		
			# weapon stats
			if weapon != None:
				weaponType = getWeaponType(weapon.templateName)
	
				#jlo:remove
				if weaponType == WEAPON_TYPE_UNKNOWN and getVehicleType(attacker.getVehicle().templateName) == VEHICLE_TYPE_SOLDIER:
					if g_debug: print "Weapon %s not registered for stats" % (weapon.templateName)
	
				if attacker != None:
					attacker.stats.weapons[weaponType].kills += 1

				if victim != None:
					if g_debug: print "victim %s killed by weapon %s type %d" % (victim.getName(), weapon.templateName, weaponType)
					victim.stats.weapons[weaponType].killedBy += 1
			
			# vehicle stats
			vehicleType = None
			if killedByEmptyVehicle:
				vehicleType = getVehicleType(object.templateName)
			else:
				vehicle = attacker.getVehicle()
				vehicleType = getVehicleType(vehicle.templateName)
				
				if vehicleType != VEHICLE_TYPE_SOLDIER:
					rootVehicle = getRootParent(vehicle)
					if rootVehicle != None:
						vehicleType = getVehicleType(rootVehicle.templateName)
		
			if vehicleType != None:				
				
				#jlo:remove
				if vehicleType == VEHICLE_TYPE_UNKNOWN:
					if g_debug: print "Vehicle %s not registered for stats" % (rootVehicle.templateName)
				
				if attacker != None:
					attacker.stats.vehicles[vehicleType].kills += 1
				if victim != None:
					victim.stats.vehicles[vehicleType].killedBy += 1
	
				# road kill
				if weapon == None and object != None:
					if g_debug: print "road kill"
					attacker.stats.vehicles[vehicleType].roadKills += 1
			else:
				print "ERROR: no vehicle type"
		
		
			# kit stats
			if attacker != None:
				kit = attacker.getKit()
				if kit != None:
					kitTemplateName = kit.templateName
					kitType = getKitType(kitTemplateName)
				else:
					kitType = attacker.lastKitType
						
				#jlo:remove
				if kitType == KIT_TYPE_UNKNOWN:
					if g_debug: print "Kit %s not registered for stats" % (kitTemplateName)
	
	
				attacker.stats.kits[kitType].kills += 1
	
	# death stats are handled in onPlayerDeath.

	collectBulletsFired(attacker)



def onPlayerDeath(victim, vehicle):

	# vehicle is already exited, as this happens before actual death. That doesnt stop us from dying in it.
	rootVehicle = getRootParent(vehicle)
	vehicleType = getVehicleType(rootVehicle.templateName)

	stopSpawned(victim)
	stopInSquad(victim)
	stopAsSql(victim)
	stopAsCmd(victim)
		
	onExitVehicle(victim, victim.soldier)
	finalizeBulletsFired(victim)
	clearBulletsFired(victim)

		
	# streaks
	victim.stats.currentDeathStreak += 1
	if victim.stats.currentDeathStreak > victim.stats.longestDeathStreak: 
		victim.stats.longestDeathStreak = victim.stats.currentDeathStreak

	victim.stats.currentKillStreak = 0 # this ends the current kill streak

	victim.stats.vehicles[vehicleType].deaths += 1
	if g_debug: print "Last vehicle type=", vehicleType

	# kit stats
	# kit is already dropped, so we have to get the last kit used
	victim.stats.kits[victim.stats.lastKitType].deaths += 1
	if g_debug: print "Last kit type=", victim.stats.lastKitType
	
	
	# weapon stats
	# weapon is already dropped, so we gave to get the last weapon used
	victim.stats.weapons[victim.stats.lastWeaponType].deaths += 1
	if g_debug: print "Last weapon type=", victim.stats.lastWeaponType



# update accuracy on weapon, kit and vehicle
def collectBulletsFired(player):
	if player == None: return
	
	# count bullets fired
	bulletsFired = player.score.bulletsFired
	totBulletsFired = 0
	kitBulletsFired = 0
	for b in bulletsFired:
		templateName = b[0]
		nr = b[1]

		weaponType = getWeaponType(templateName)
		player.stats.weapons[weaponType].bulletsFiredTemp = nr
		totBulletsFired += nr

		# only count kit stats for soldier-type weapons
		if weaponType != WEAPON_TYPE_UNKNOWN:
			kitBulletsFired += nr
					
	
	# count bullets hit 
	bulletsHit = player.score.bulletsGivingDamage
	totBulletsHit = 0
	kitBulletsHit = 0
	for b in bulletsHit:
		templateName = b[0]
		nr = b[1]

		weaponType = getWeaponType(templateName)
		player.stats.weapons[weaponType].bulletsHitTemp = nr
		totBulletsHit += nr

		# only count kit stats for soldier-type weapons
		if weaponType != WEAPON_TYPE_UNKNOWN:
			kitBulletsHit += nr
	

	# dont bother giving kit stats if we're in a vehicle
	kit = player.getKit()
	if kit != None:
		kitType = getKitType(kit.templateName)
		player.stats.kits[kitType].bulletsFiredTemp = kitBulletsFired
		player.stats.kits[kitType].bulletsHitTemp = kitBulletsHit

	vehicle = player.getVehicle()
	if vehicle != None:
		rootVehicle = getRootParent(vehicle)
		vehicleType = getVehicleType(rootVehicle.templateName)

		player.stats.vehicles[vehicleType].bulletsFiredTemp = totBulletsFired
		player.stats.vehicles[vehicleType].bulletsHitTemp = totBulletsHit
		

def clearBulletsFired(player):
	bulletsFired = player.score.bulletsFiredAndClear
	bulletsHit = player.score.bulletsGivingDamageAndClear

def finalizeBulletsFired(player):
	for v in player.stats.vehicles.itervalues():
		v.bulletsFired += v.bulletsFiredTemp
		v.bulletsHit += v.bulletsHitTemp
		v.bulletsFiredTemp = 0
		v.bulletsHitTemp = 0
	for w in player.stats.weapons.itervalues():
		w.bulletsFired += w.bulletsFiredTemp
		w.bulletsHit += w.bulletsHitTemp
		player.stats.bulletsFired += w.bulletsFiredTemp
		player.stats.bulletsHit += w.bulletsHitTemp
		w.bulletsFiredTemp = 0
		w.bulletsHitTemp = 0
	for k in player.stats.kits.itervalues():
		k.bulletsFired += k.bulletsFiredTemp
		k.bulletsHit += k.bulletsHitTemp
		k.bulletsFiredTemp = 0
		k.bulletsHitTemp = 0

# squad tracking
def startSpawned(player): 
	player.stats.spawnedAt = date()
	player.stats.spawnedTeam = player.getTeam()
def startInSquad(player): player.stats.joinedSquadAt = date()
def startAsSql(player): player.stats.becameSqlAt = date()
def startAsCmd(player): player.stats.becameCmdAt = date()

def stopSpawned(player):
	time = player.stats.timePlayed
	player.stats.spawnedAt = 0
	player.stats.spawnedTeam = 3
def stopInSquad(player): 
	time = player.stats.timeInSquad
	player.stats.joinedSquadAt = 0
def stopAsSql(player): 
	time = player.stats.timeAsSql
	player.stats.becameSqlAt = 0
def stopAsCmd(player): 
	time = player.stats.timeAsCmd
	player.stats.becameCmdAt = 0
	
def onPlayerScore(player, difference):
	pass

def onChangedCommander(team, oldCmd, newCmd):
	oc = -1
	if oldCmd: oc = oldCmd.index
	nc = -1
	if newCmd: nc = newCmd.index
	#if g_debug: print "Changed cmd in team %d from %d to %d" % (team, oc, nc)

	if newCmd and newCmd.stats.spawnedAt != 0: startAsCmd(newCmd)
	if oldCmd: stopAsCmd(oldCmd)
	
def onChangedSquadLeader(squad, oldSql, newSql):
	oq = -1
	if oldSql: oq= oldSql.index
	nq = -1
	if newSql: nq = newSql.index
	#if g_debug: print "Changed sql in squad %d from %d to %d" % (squad, oq, nq)

	if newSql and newSql.stats.spawnedAt != 0: startAsSql(newSql)
	if oldSql: stopAsSql(oldSql)

	
def onPlayerChangedSquad(player, oldSquad, newSquad):
	#if g_debug: print "Player %d changed from squad %d to squad %d" % (player.index, oldSquad, newSquad)
	if oldSquad == newSquad:
		return

	if player.stats.spawnedAt == 0:
		return
	
	if oldSquad == 0: startInSquad(player)
	if newSquad == 0: 
		stopAsSql(player)
		stopInSquad(player)
	
	
def onPlayerBanned(player, time, type):
	if g_debug: print "Player %s banned type %d" % (player.getName(), type)
	if type == 2: return # dont count round bans
	
	player.stats.timesBanned += 1
	

def onPlayerKicked(player):
	if g_debug: print "Player %s kicked" % (player.getName())
	player.stats.timesKicked += 1



import host
import bf2.PlayerManager
from bf2.stats.constants import *
from bf2 import g_debug

# map gamespy item ids to kits
unlockItemMap = {
			11 : 0,
			22 : 1,
			33 : 2,
			44 : 3,
			55 : 4,
			66 : 5,
			77 : 6,
		}

sessionPlayerUnlockMap = {}

def init():
	# Events
	host.registerHandler('PlayerConnect', onPlayerConnect, 1)
	
	if bf2.serverSettings.getUseGlobalUnlocks():
		host.registerHandler('PlayerUnlocksResponse', onUnlocksResponse, 1)

	# Connect already connected players if reinitializing
	for p in bf2.playerManager.getPlayers():
		onPlayerConnect(p)

	if g_debug: print "Unlock module initialized"


class UnlockSet: pass


def onPlayerConnect(player):

	defaultUnlocks = [1, 1, 1, 1, 1, 1, 1]
	host.pers_plrSetUnlocks(player.index, defaultUnlocks, defaultUnlocks)

	if not player.isAIPlayer():
		id = player.index
		reconnect = id in sessionPlayerUnlockMap
		
		# always get new unlocks on reconnect/map restart/map change etc
		if reconnect:
			del sessionPlayerUnlockMap[id]
			
		newUnlockSet = UnlockSet()

		newUnlockSet.unlockLevel = {}
		for i in range(0, NUM_KIT_TYPES):
			newUnlockSet.unlockLevel[i] = 0

		sessionPlayerUnlockMap[id] = newUnlockSet
		
		player.unlocks = sessionPlayerUnlockMap[id]

		if bf2.serverSettings.getUseGlobalUnlocks():
			if player.getProfileId() > 2000:		
				success = host.pers_plrRequestUnlocks(player.index, 1)
				if not success:
					if g_debug: print "Failed requesting unlocks"
			else:
				if g_debug: print "Player %d had no profile id, can't request unlocks" % player.index
				
		if g_debug: print "Added player %d to unlock checking" % (player.index)
		

def onUnlocksResponse(succeeded, player, unlocks):
	if not succeeded:
		print "Unlocks request failed for player %d %d: %s" % (player.index, player.getName(), unlocks)
		return
	
	print "Unlocks received for player ", player.getName(), "(",player.index, ") : ", unlocks
	
	# translate gamespy item vector into a kit-based unlock vector handled by game
	kitUnlocks = [0, 0, 0, 0, 0, 0, 0]
	for item in unlocks:
		if item in unlockItemMap:
			kitUnlocks[unlockItemMap[item]] = 1
		
	if g_debug: print "Kit unlocks: ", kitUnlocks
	
	#We do not yet support giving different unlocks to different teams
	host.pers_plrSetUnlocks(player.index, kitUnlocks, kitUnlocks)




# vim: ts=4 noexpandtab
#
# Battlefield II -- default remote console module.
#
# This is a very simple, TCP based remote console which does simple MD5 digest
# password authentication. It can be configured via the admin/default.cfg file.
# Recognized options are 'port' and 'password'.
#
# Implementation guidelines for this file (and for your own rcon modules):
#
#  - All socket operations MUST be non-blocking. If your module blocks on a
#    socket the game server will hang.
#
#  - Do as little work as possible in update() as it runs in the server main
#    loop.
#
# Other notes:
#
#  - To get end-of-message markers (0x04 hex) after each reply, begin your
#    commands with an ascii 0x02 code. This module will then append the
#    end-of-message marker to all results. This is useful if you need to wait
#    for a complete response.
#
# Copyright (c)2004 Digital Illusions CE AB
# Author: Andreas `dep' Fredriksson

import socket
import errno
import host
import bf2
import types
import md5
import string
import random

options = {
	'port': '4711',
	'password': None,

	# True if multiple commands should be processed in one update and
	# if as many responses as possible should be sent each update.
	'allowBatching': False
}

# Returns a seed string of random characters to be used as a salt to protect
# password sniffing.
def make_seed(seed_length):
	return ''.join([string.ascii_letters[random.randint(0, len(string.ascii_letters)-1)] for x in xrange(0, seed_length)])

# Concats a seed string with the password and returns an ASCII-hex MD5 digest.
def digest(seed, pw):
	if not pw: return None
	m = md5.new()
	m.update(seed)
	m.update(pw)
	return m.hexdigest()

# Parses the config file, if it's there
def parseConfig():
	def boolFromString (str):
		if str in ['True', 'true', '1']:
			return True
		elif value in ['False', 'false', '0']:
			return False
		else:
			raise ValueError

	fn = 'admin/default.cfg'
	try:
		config = open(fn, 'r')
		lineNo = 0
		for line in config:
			lineNo += 1
			if line.strip() != '' and line.strip() != '\n':
				try:
					(key, value) = line.split('=')
					key = key.strip()
					value = value.strip()
					
					if key == 'allowBatching': value = boolFromString (value)
					options[key] = value
					
				except ValueError:
					print 'warning: syntax error in "%s" on line %d' % (fn, lineNo)
	except IOError, detail:
		print 'warning: couldn\'t read "%s": %s' % (fn, detail)

# A stateful output buffer that knows how to enqueue data and ship it out
# without blocking.
class OutputBuffer(object):

	def __init__(self, sock):
		self.sock = sock
		self.data = []
		self.index = 0

	def enqueue(self, str):
		self.data.append(str)

	def update(self):
		allowBatching = options['allowBatching']
		while len(self.data) > 0:
			try:
				item = self.data[0]
				scount = self.sock.send(item[self.index:])
				self.index += scount
				if self.index == len(item):
					del self.data[0]
					self.index = 0
			except socket.error, detail:
				if detail[0] != errno.EWOULDBLOCK:
					return detail[1]
			if not allowBatching:
				break
		return None

# Each TCP connection is represented by an object of this class.
class AdminConnection(object):

	def __init__(self, srv, sock, addr):
		print 'new rcon/admin connection from %s:%d' % (addr[0], addr[1])
		self.server = srv
		self.sock = sock
		self.addr = addr
		self.sock.setblocking(0)
		self.buffer = ''
		self.seed = make_seed(16)
		self.correct_digest = digest(self.seed, options['password'])
		self.outbuf = OutputBuffer(self.sock)
		
		# Welcome message *must* end with \n\n
		self.outbuf.enqueue('### Battlefield 2 default RCON/admin ready.\n')
		self.outbuf.enqueue('### Digest seed: %s\n' % (self.seed))
		self.outbuf.enqueue('\n') # terminate welcome message with extra LF

	def update(self):
		err = None
		try:
			allowBatching = options['allowBatching']
			while not err:
				data = self.sock.recv(1024)
				if data:
					self.buffer += data
					while not err:
						nlpos = self.buffer.find('\n')
						if nlpos != -1:
							self.server.onRemoteCommand(self, self.buffer[0:nlpos])
							self.buffer = self.buffer[nlpos+1:] # keep rest of buffer
						else:
							if len(self.buffer) > 128:
								err = 'data format error: no newline in message'
							break
						if not allowBatching: break
				else:
					err = 'peer disconnected'
				
				if not allowBatching: break

		except socket.error, detail:
			if detail[0] != errno.EWOULDBLOCK:
				err = detail[1]

		if not err:
			err = self.outbuf.update()

		if err:
			print 'rcon: closing %s:%d: %s' % (self.addr[0], self.addr[1], err)
			try:
				self.sock.shutdown(2)
				self.sock.close()
			except:
				print 'rcon: warning: failed to close %s' % (self.addr)
				pass
			return 0
		else:
			return 1

# Context passed to remote command implementations for them to write output to
# either a remote tcp socket or an in-game client executing 'rcon <command>'.
class CommandContext(object):
	def __init__(self):
		self.player = None
		self.socket = None
		self.output = []

	def isInGame(self): return self.player is not None
	def isSocket(self): return self.socket is not None
	def write(self, text): self.output.append(text)

# The server itself.
class AdminServer(object):

	def __init__(self, port):
		# state for tcp rcon connections
		self.port = port
		self.backlog = 1
		self.peers = []
		self.openSocket()

		# state for in-game rcon connections
		host.registerHandler('RemoteCommand', self.onRemoteCommand, 1)
		host.registerHandler('PlayerDisconnect', self.onPlayerDisconnect, 1)
		host.registerHandler('ChatMessage', self.onChatMessage, 1)

		# contains player ids for players which have successfully authenticated
		# themselves with 'rcon login <passwd>'
		self.authed_players = {}
		# contains sockets for connections which have successfully authenticated
		# themselves with 'login <passwd>'
		self.authed_sockets = {}

		# rcon commands supported in this vanilla version
		self.rcon_cmds = {
			'login': self.rcmd_login,
			'users': self.rcmd_users,
			'exec': self.rcmd_exec
		}

	# Called when a user types 'rcon ' followed by any string in a client
	# console window or when a TCP client sends a complete line to be
	# evaluated.
	def onRemoteCommand(self, playerid_or_socket, cmd):
		cmd = cmd.strip()
		interactive = True

		# Is this a non-interactive client?
		if len(cmd) > 0 and cmd[0] == '\x02':
			cmd = cmd[1:]
			interactive = False

		spacepos = cmd.find(' ')
		if spacepos == -1: spacepos=len(cmd)
		subcmd = cmd[0:spacepos]

		ctx = CommandContext()
		authed = 0
		if type(playerid_or_socket) == types.IntType:
			ctx.player = playerid_or_socket
			authed = self.authed_players.has_key(ctx.player)
		else:
			ctx.socket = playerid_or_socket
			authed = self.authed_sockets.has_key(ctx.socket)
			
		# you can only login unless you are authenticated
		if subcmd != 'login' and not authed:
			ctx.write('error: not authenticated: you can only invoke \'login\'\n')
		else:
			if self.rcon_cmds.has_key(subcmd):
				self.rcon_cmds[subcmd](ctx, cmd[spacepos+1:])
			else:
				ctx.write('unknown command: \'%s\'\n' % (subcmd))

		feedback = ''.join(ctx.output)
		if ctx.socket:
			if interactive:
				ctx.socket.outbuf.enqueue(feedback)
			else:
				ctx.socket.outbuf.enqueue(feedback + '\x04')
		else:
			host.rcon_feedback(ctx.player, feedback)

	# When players disconnect, remove them from the auth map if they were
	# authenticated so that the next user with the same id doesn't get rcon
	# access.
	def onPlayerDisconnect(self, player_id):
		if self.authed_players.has_key(player_id):
			del self.authed_players[player_id]

	# Called whenever a player issues a chat string.
	def onChatMessage(self, player_id, text, channel, flags):
		print 'chat: pid=%d text=\'%s\' channel=%s' % (player_id, text, channel)

	# Sets up the listening TCP RCON socket. This binds to 0.0.0.0, which may
	# not be what you want but it's a sane default for most installations.
	def openSocket(self):
		try:
			self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			#self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, 0)
			#self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
			self.sock.bind(('0.0.0.0', self.port))
			self.sock.listen(self.backlog)
			self.sock.setblocking(0)
		except socket.error, detail:
			print 'failed to bind rcon socket--only in-game rcon will be enabled'

	# WARNING: update is called very frequently -- don't go crazy with logic
	# here.
	def update(self):
		# if we don't have a socket, just return
		if not self.sock: return

		# without blocking, check for new connections
		try:
			conn, peeraddr = self.sock.accept()
			self.peers.append(AdminConnection(self, conn, peeraddr))
		except socket.error, detail:
			if detail[0] != errno.EWOULDBLOCK:
				raise socket.error, detail

		# update clients and mark connections that fail their update
		disc = []
		for client in self.peers:
			if not client.update(): disc.append(client)

		# delete any auth status for closed tcp connections
		for d in disc:
			if self.authed_sockets.has_key(d): del self.authed_sockets[d]

		# now keep the remaining clients
		self.peers = filter(lambda x: x not in disc, self.peers)

	def shutdown(self):
		if self.sock:
			self.sock.close()

	# Command implementations go here (member functions of the AdminServer)

	# Allows a in-game rcon client to authenticate and get access.
	def rcmd_login(self, ctx, cmd):
		success = 0
		if ctx.isInGame():
			# We're called by an in-game rcon client, use plain-text password
			# (encoded into bf2 network stream).
			if cmd.strip() == options['password']:
					self.authed_players[ctx.player] = 1
					success = 1
			elif self.authed_players.has_key(ctx.player):
					del self.authed_players[ctx.player]
		else:
			# tcp client, require seeded digest to match instead of pw
			if cmd.strip() == ctx.socket.correct_digest:
				self.authed_sockets[ctx.socket] = 1
				print 'rcon: tcp client from %s:%d logged on' % ctx.socket.addr
				success = 1
			else:
				if self.authed_sockets.has_key(ctx.socket):
					del self.authed_sockets[ctx.socket]
				print 'rcon: tcp client from %s:%d failed pw challenge' % ctx.socket.addr

		if success:
			ctx.write('Authentication successful, rcon ready.\n')
		else:
			ctx.write('Authentication failed.\n')

	# Lists rcon-authenticated players.
	def rcmd_users(self, ctx, cmd):
		ctx.write('active rcon users:\n')
		for id in self.authed_players:
			if id == -1:
				ctx.write('-1 (local server console)\n')
			else:
				try:
					player = bf2.playerManager.getPlayerByIndex(id)
					ctx.write('%d from %s name=\'%s\'\n' % (id, player.getAddress(), player.getName()))
				except:
					ctx.write('%d (no info)\n' % (id))

		for peer in self.authed_sockets:
			ctx.write('tcp: %s:%d\n' % (peer.addr[0], peer.addr[1]))

	# Executes a console command on the server.
	def rcmd_exec(self, ctx, cmd):
		ctx.write(host.rcon_invoke(cmd))

# parse the configuration file
parseConfig()

# our single server instance
server = AdminServer(int(options['port']))

# These functions are called from the engine -- we implement them in terms of a
# class instance:


def init():
	print 'initializing default admin/rcon module'
	
	# load (optional) admin scripts like teamkill punish and autobalance
	import standard_admin


def shutdown():
	if server:
		print 'shutting down default admin/rcon module'
		server.shutdown()

def update():
	if server: server.update()



# team autobalance system

import bf2
import host
from bf2 import g_debug

def init():
	if g_debug: print 'initializing autobalance script'
	
	host.registerHandler('PlayerConnect', onPlayerConnect)	
	host.registerHandler('PlayerDeath', onPlayerDeath)
	host.registerHandler('PlayerChangeTeams', onPlayerChangeTeams)


def onPlayerConnect(p):
	# if not bf2.serverSettings.getAutoBalanceTeam(): return None	
	if g_debug: print 'place player on the team with least players'

	team1 = 0
	team2 = 0
	for tp in bf2.playerManager.getPlayers():
		if tp != p:
			if tp.getTeam() == 1: team1 += 1
			else: team2 += 1	
			
	team2 = team2 * bf2.serverSettings.getTeamRatioPercent() / 100.0		
	if team2 > team1:
		p.setTeam(1)
	else:
		p.setTeam(2)
		
def onPlayerDeath(p, vehicle):			
	if not bf2.serverSettings.getAutoBalanceTeam(): return None	
	if g_debug: print 'handling player death autobalance'	
	
	# dont use autobalance when its suicide/changes team
	if p.getSuicide(): 
		p.setSuicide(0)
		return None		
	
	aiPlayerBalance = 0
	team1 = 0
	team2 = 0
	for tp in bf2.playerManager.getPlayers():	
		if tp.getTeam() == 1:
			team1 += 1
		else:
			team2 += 1
		if tp.isAIPlayer():
			aiPlayerBalance += 1
		else:
			aiPlayerBalance -= 1					
	
	if host.sgl_getIsAIGame():
		if not (aiPlayerBalance < 0):		
			if not p.isAIPlayer():
				return None	
			
	team2 = team2 * bf2.serverSettings.getTeamRatioPercent() / 100.0
	if g_debug: print 'team1 %f team2 %f' % (team1,team2)	
	if (p.getTeam() == 1):
		if (team2+1) < team1:
			p.setTeam(2)			
	elif (p.getTeam() == 2):
		if (team1+1) < team2:
			p.setTeam(1)			
		
def onPlayerChangeTeams(p, humanHasSpawned):
	if not bf2.serverSettings.getAutoBalanceTeam(): return None
	if host.sgl_getIsAIGame(): 		
		if humanHasSpawned: return None
		if p.isAIPlayer(): return None
	
		if g_debug: print 'handling aiplayer team change autobalance when round not started'
	
		team = p.getTeam()	
		aiplayer = 0	
	
		for tp in bf2.playerManager.getPlayers():		
			if aiplayer == 0 and tp.getTeam() == team and tp.isAIPlayer(): 
				aiplayer = tp
				break
		
		if aiplayer: 
			if p.getTeam() == 1: aiplayer.setTeam(2)
			else: aiplayer.setTeam(1)
									
	else:
		if g_debug: print 'checking to see if player is allowed to change teams'
	
		team1 = 0
		team2 = 0
		for tp in bf2.playerManager.getPlayers():	
			if tp.getTeam() == 1: team1 += 1
			else: team2 += 1
		if abs(team1 - team2) > 1:
			if p.getTeam() == 1: p.setTeam(2)
			else: p.setTeam(1)
	

# tk punish system

import bf2
import host
from bf2 import g_debug

TK_PUNISH_TIME = 20

TK_PUNISH_COMMANDID = 100
TK_FORGIVE_COMMANDID = 101

hasPendingTks = {}
updateTimer = None


class TkData:
	def __init__(self):
		self.punished = 0
		self.pending = []
		self.lastTKedBy = None


def init():
	if g_debug: print "initializing tk-punish script"

	host.registerHandler('PlayerConnect', onPlayerConnect, 1)
	host.registerHandler('PlayerKilled', onPlayerKilled)
	host.registerHandler('ClientCommand', onClientCommand)

	# Connect already connected players if reinitializing
	for p in bf2.playerManager.getPlayers():
		onPlayerConnect(p)
	
	checkEnable()


def checkEnable():
	global updateTimer
	
	if not bf2.serverSettings.getTKPunishEnabled():
		if updateTimer:
			updateTimer.destroy()
			updateTimer = None
		return False
	else:
		if not updateTimer:
			#if g_debug: print "Started timer"
			updateTimer = bf2.Timer(onUpdate, 10, 1)
			updateTimer.setRecurring(10)
			
		return True
	

def onUpdate(data):
	if not checkEnable(): return
	global hasPendingTks

	#if len(hasPendingTks) > 0:
	#	if g_debug: print "update: Has pending tks!"
	#else:
	#	if g_debug: print "update:No pending tks."
		

	currentTime = host.timer_getWallTime()

	newPending = {}
	for attacker in hasPendingTks.iterkeys():
		newList = []
		#if g_debug: print "attacker pending list:", len(attacker.tkData.pending)
		for tk in attacker.tkData.pending:
			tkDate = tk[0]
			tkVictim = tk[1]
			#if g_debug: print "check %d %s" % (tkDate, tkVictim.getName())

			# if there is a pending TK with time expired
			if tkDate + TK_PUNISH_TIME < currentTime:
				if bf2.serverSettings.getTKPunishByDefault():
					attacker.tkData.punished += 1
					checkPunishLimit(attacker)
				#	if g_debug: print "Default punished ", attacker.getName()
				else:
				#	if g_debug: print "Timeouted pending tk for ", attacker.getName()
					pass

				# remove player from global list, if it was the last tk
				if len(attacker.tkData.pending) == 1:
					pass
				else:
					newPending[attacker] = 1
			
			else:
				newList += [tk]
				newPending[attacker] = 1
		
		attacker.tkData.pending = newList

	hasPendingTks = newPending
	
						
def checkPunishLimit(player):
	#if g_debug: print "player %s has %d punishes" % (player.getName(), player.tkData.punished)

	if player.tkData.punished >= bf2.serverSettings.getTKNumPunishToKick():
		if g_debug: print "%s reached punish limit" % player.getName()
		if g_debug: print "Banning player!"
		
		result = host.rcon_invoke("admin.banPlayer " + str(player.index) + " Round")
		





# event actions	

def onPlayerConnect(player):
	player.tkData = TkData()


def onClientCommand(command, issuer, args):
	if not checkEnable(): return
	
	#if g_debug: print "received client command"
	if command == TK_PUNISH_COMMANDID:
		executePunishAction(issuer, True)
	elif command == TK_FORGIVE_COMMANDID:
		executePunishAction(issuer, False)
		

def onPlayerKilled(victim, attacker, weapon, assists, object):
	if not checkEnable(): return

	if not victim or not attacker or victim == attacker or victim.getTeam() != attacker.getTeam(): return
	
	# ok, we have a teamkill
	
	currentTime = host.timer_getWallTime()
	attacker.tkData.pending += [(currentTime, victim)]
	hasPendingTks[attacker] = 1
		
	victim.tkData.lastTKedBy = attacker # can only punish / forgive the last TK'er
	
	bf2.gameLogic.sendClientCommand(victim.index, 100, (2, victim.index, attacker.index, TK_PUNISH_TIME))


def executePunishAction(victim, punish):
	if not checkEnable() or not victim or not victim.isValid(): return
	attacker = victim.tkData.lastTKedBy
	if attacker == None or not attacker.isValid(): return

	global hasPendingTks

	if punish:
		if g_debug: print "%s tkPunished %s" % (victim.getName(), attacker.getName())
	else:
		if g_debug: print "%s tkForgive %s" % (victim.getName(), attacker.getName())

	currentTime = host.timer_getWallTime()
	
	newList = []
	for tk in attacker.tkData.pending:
		tkDate = tk[0]
		tkVictim = tk[1]
		
		# if the attacker had a pending tk, and time has not run out
		if tkVictim == victim and tkDate + TK_PUNISH_TIME > currentTime:
			if punish:
				attacker.tkData.punished += 1
				bf2.gameLogic.sendClientCommand(-1, 100, (0, victim.index, attacker.index)) # 100 = tkpunish event, 0 = punish
				if g_debug: print "%s punished %s, now has %d punishes" % (victim.getName(), attacker.getName(), attacker.tkData.punished)
			else:
				bf2.gameLogic.sendClientCommand(-1, 100, (1, victim.index, attacker.index)) # 100 = tkpunish event, 1 = forgive
				if g_debug: print "%s forgave %s" % (victim.getName(), attacker.getName())
		else:
			newList += [tk]
			
	attacker.tkData.pending = newList
	
	if len(attacker.tkData.pending) == 0:
		del hasPendingTks[attacker]
	
	checkPunishLimit(attacker)



# setup.py
from distutils.core import setup
import py2exe
      
setup(console=['remoteconsole.py'])




#! /usr/bin/python
# vim: ts=4 noexpandtab
#
# Battlefield II -- default remote console client
#
# This is a very simple, TCP based remote console client which does MD5 digest
# password authentication.
#
# Recognized command-line options are -h for host and -p for port.
#
# Copyright (c)2004 Digital Illusions CE AB
# Author: Andreas `dep' Fredriksson

import md5
import socket
import errno

# Concats a seed string with the password and returns an ASCII-hex MD5 digest.
def digest(seed, pw):
	if not pw: return None
	m = md5.new()
	m.update(seed)
	m.update(pw)
	return m.hexdigest()

# Client class.
class RconClient:
	def __init__(self):
		self.sock = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
		self.trace = 0
		self.challenge = None

	def connect (self, host, port):
		self.sock.connect ((host, port))
		response = self.getWelcomeResponse()

		# Dig out the seed
		prefix = '### Digest seed: '
		challpos = response.find(prefix)
		if challpos != -1:
			challpos += len(prefix)
			challend = response.find('\n', challpos)
			self.challenge = response[challpos:challend]
			if self.trace: print "S: challenge: ", self.challenge
		if self.trace: print "S:", response
		return response

	def invoke (self, cmd):
		if self.trace: print "C:", cmd
		self.sock.send ('\x02' + cmd + '\n') # This is a non-interactive command.
		response = self.getResponse()
		if self.trace: print "S:", response
		return response

	# Read data until two newlines are encountered
	def getWelcomeResponse (self):
		result = ""
		while 1:
			data = self.sock.recv(1024)
			result += data
			lflfpos = result.find('\n\n')
			if lflfpos != -1: break
		return result

	def getResponse (self):
		result = ""
		done = False
		while not done:
			data = self.sock.recv(1024)
			for c in data:
				if c == '\x04':
					done = True
					break
				result += c
		return result



if __name__ == '__main__':
	from getopt import getopt
	import sys

	host = 'localhost'
	port = 4711

	opts, args = getopt(sys.argv[1:], 'h:p:')
	for k, v in opts:
		if k == '-h': host = v
		elif k == '-p': port = int(v)

	print 'Connecting to %s, port %d..' % (host, port)

	try:
		conn = RconClient()
		conn.connect(host, port)
		while 1:
			pw = raw_input('Password: ')
			d = digest(conn.challenge, pw)
			result = conn.invoke('login %s' % d)
			if result.startswith('Authentication success'): break
			print 'Invalid password, please try again'

		while 1:
			cmd = raw_input('rcon> ')
			if cmd == 'login':
				print 'Already authenticated'
				continue

			if cmd == 'quit': break
			result = conn.invoke(cmd)
			print result

	except socket.error, detail:
		print 'Network error:', detail[1]

	except EOFError:
		pass
